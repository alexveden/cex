#pragma once
#include "cex.h"
#include "str.h"
#include <string.h>

typedef struct dict_c
{
    void* hashmap; // any generic hashmap implementation
} dict_c;

typedef u64 (*dict_hash_func_f)(const void* item, u64 seed0, u64 seed1);
typedef int (*dict_compare_func_f)(const void* a, const void* b, void* udata);
typedef void (*dict_elfree_func_f)(void* item);


// Hack for getting hash/cmp functions by a type of key field
// https://gustedt.wordpress.com/2015/05/11/the-controlling-expression-of-_generic/
// FIX: this is not compatible with MSVC
#define _dict$hashfunc_field(strucfield)                                                           \
    _Generic(&(strucfield), u64 *: dict.hashfunc.u64_hash, char(*)[]: dict.hashfunc.str_hash)

#define _dict$cmpfunc_field(strucfield)                                                            \
    _Generic(&(strucfield), u64 *: dict.hashfunc.u64_cmp, char(*)[]: dict.hashfunc.str_cmp)

#define _dict$hashfunc(struct, field) _dict$hashfunc_field(((struct){ 0 }.field))

#define _dict$cmpfunc(struct, field) _dict$cmpfunc_field(((struct){ 0 }.field))



#define dict$new(self, struct_type, key_field_name, allocator)                                     \
    dict.create(                                                                                   \
        self,                                                                                      \
        sizeof(struct_type),                                                                       \
        _Alignof(struct_type),                                                                     \
        offsetof(struct_type, key_field_name),                                                     \
        0, /* capacity = 0, default is 16 */                                                       \
        _dict$hashfunc(struct_type, key_field_name),                                               \
        _dict$cmpfunc(struct_type, key_field_name),                                                \
        allocator,                                                                                 \
        NULL, /* elfree - function for clearing elements */                                        \
        NULL  /* udata - passed as a context for cmp funcs */                                      \
    )


struct __module__dict
{
    // Autogenerated by CEX
    // clang-format off


struct {  // sub-module .hashfunc >>>
    /**
     * @brief Hashmap: int compare function
     *
     * @param a as u64
     * @param b as u64
     * @param udata (unused)
     * @return
     */
    int
    (*u64_cmp)(const void* a, const void* b, void* udata);

    /**
     * @brief Hashmap: int hash function, for making ticker_id -> hash (uniformly distrib)
     *
     * @param item (u64) item (ticker id)
     * @param seed0 (unused)
     * @param seed1 (unused)
     * @return hash value
     */
    u64
    (*u64_hash)(const void* item, u64 seed0, u64 seed1);

    /**
     * @brief Compares static char[] buffer keys **must be null terminated**
     *
     * @param a  char[N] string
     * @param b  char[N] string
     * @param udata  (unused)
     * @return compared int value
     */
    int
    (*str_cmp)(const void* a, const void* b, void* udata);

    /**
     * @brief Compares static char[] buffer keys **must be null terminated**
     *
     * @param item
     * @param seed0
     * @param seed1
     * @return
     */
    u64
    (*str_hash)(const void* item, u64 seed0, u64 seed1);

} hashfunc;  // sub-module .hashfunc <<<
Exception
(*create)(dict_c* self, size_t item_size, size_t item_align, size_t item_key_offsetof, size_t capacity, dict_hash_func_f hash_func, dict_compare_func_f compare_func, const Allocator_i* allocator, dict_elfree_func_f elfree, void* udata);

/**
 * @brief Set or replace dict item
 *
 * @param self dict() instance
 * @param item  item key/value struct
 * @return error code, EOK (0!) on success, positive on failure
 */
Exception
(*set)(dict_c* self, const void* item);

/**
 * @brief Get item by integer key
 *
 * @param self dict() instance
 * @param key u64 key
 */
void*
(*geti)(dict_c* self, u64 key);

/**
 * @brief Get item by generic key pointer (including strings)
 *
 * @param self dict() instance
 * @param key generic pointer key
 */
void*
(*get)(dict_c* self, const void* key);

/**
 * @brief Number elements in dict()
 *
 * @param self  dict() instance
 * @return number
 */
size_t
(*len)(dict_c* self);

/**
 * @brief Free dict() instance
 *
 * @param self  dict() instance
 * @return always NULL
 */
void
(*destroy)(dict_c* self);

/**
 * @brief Clear all elements in dict (but allocated capacity unchanged)
 *
 * @param self dict() instane
 */
void
(*clear)(dict_c* self);

/**
 * @brief Delete item by integer key
 *
 * @param self dict() instance
 * @param key u64 key
 */
void*
(*deli)(dict_c* self, u64 key);

/**
 * @brief Delete item by generic key pointer (including strings)
 *
 * @param self dict() instance
 * @param key generic pointer key
 */
void*
(*del)(dict_c* self, const void* key);

void*
(*iter)(dict_c* self, cex_iterator_s* iterator);

Exception
(*tolist)(dict_c* self, void* listptr, const Allocator_i* allocator);

    // clang-format on
};
extern const struct __module__dict dict; // CEX Autogen
