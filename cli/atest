#!/usr/bin/env python3
# -flake8: noqa
import subprocess
import argparse
import os
import sys
import pickle
import re
import io

TEMPLATE = r"""
#include "atest.h"
#include <stdio.h>
#include <math.h>

/*
* SUITE INIT / SHUTDOWN
*/
void my_test_shutdown_func(void){
    // instead of printf(....) consider to use alogf() it's more structural and contains line source:lnumber reference
    // atlogf("atest_shutdown()\n");
}

ATEST_SETUP_F(void)
{
    // atlogf("atest_setup()\n");

    //return NULL;   // if no shutdown logic needed
    return &my_test_shutdown_func;  // return pointer to void some_shutdown_func(void)
}

/*
*
*   TEST SUITE
*
*/

ATEST_F(test_){
    // instead of printf(....) consider to use alogf() it's more structural and contains line source:lnumber reference
    //atlogf("something to log if fail, %d\n", 777);
    //atassert_eqs("b", "axb");
    //atassert(1 == 0)
    //atassertf(exp == act, "expected: %d != actual: %d", exp, act);

    // Place new test here

    return NULL; // Every ATEST_F() must return NULL to succeed!
}


/*
*
* MAIN (AUTO GENERATED)
*
*/
int main(int argc, char *argv[])
{
    ATEST_PARSE_MAINARGS(argc, argv);
    ATEST_PRINT_HEAD();  // new tests go below >>>>

    ATEST_PRINT_FOOTER(); // <<<< test list ends above
    return ATEST_EXITCODE();
}
"""

TEMPLATE_WRAPPER = """
/**********************************************************************************/
// System function wrapper (auto-generated by ATEST)
// Note: don't forget add linker frags "-Wl,--wrap=...,--wrap=${func_name},..."
//
${doc}
extern ${ret_type} ${ret_ptr} __real_${func_name}(${func_def_args});

${ret_type} ${ret_ptr} __wrap_${func_name}(${func_def_args})
{
    if (__ATestContext.in_test == NULL)
        return __real_${func_name}(${func_call_args}); // Calls outside test suite

    // TODO: replace testcase name, adjust return value, and errno
    if (strcmp(__ATestContext.in_test, "testcase__${func_name}") == 0) {
        // Specific behavior for a specific test name
        atlogf("__wrap_${func_name}: %s -> stub\\n", __ATestContext.in_test);
        // errno = EBADSLT;  // optionally set global errno value
        return ${bad_ret};
    } else {
        // Other test calls fallback option
        atlogf("__wrap_${func_name}: %s -> real\\n", __ATestContext.in_test);
        return __real_${func_name}(${func_call_args});
    }
}
// end of <${func_name}> wrapper
/**********************************************************************************/
"""


def get_man_page_signature(func_name: str):
    doc_buf = io.StringIO()
    man_lines = None
    for man_n in [2, 3]:
        func_man = subprocess.Popen(
            ("man", str(man_n), func_name),
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
        )
        man_print = subprocess.check_output(("col", "-bx"), stdin=func_man.stdout)
        if func_man.wait() == 0:
            man_lines = man_print.decode().split("\n")
            break

    if not man_lines:
        raise ValueError(f"Function {func_name} not found in man pages")
    section = ""
    re_signature = re.compile(r"\s*(.*)\s+([\*])*([a-zA-z0-9_]+)\((.*)\);")
    re_args = re.compile(r"^.*\s+[\*]*([a-zA-Z_.]+)$", re.MULTILINE)
    doc_buf.write("// ")
    doc_buf.write(man_lines[0])
    doc_buf.write("\n")

    sig_comp_line = ""
    for line in man_lines:
        line = line.strip()
        if not line:
            continue

        if line == "NAME":
            section = "NAME"
            continue
        elif line == "SYNOPSIS":
            section = "SYNOPSIS"
            continue
        elif line == "DESCRIPTION":
            section = "DESCRIPTION"
            continue

        if section == "NAME":
            doc_buf.write(f"// {line.strip()}\n")
        if section == "SYNOPSIS":
            if "#include" in line:
                doc_buf.write(f"// {line}\n")
                continue

            if func_name in line and ";" not in line:
                sig_comp_line += " " + line
                continue

            if sig_comp_line:
                sig_comp_line += " " + line
                if ";" not in line:
                    continue

            m = re_signature.match(sig_comp_line if sig_comp_line else line)

            if m:
                if m[3] != func_name:
                    continue
                if sig_comp_line:
                    doc_buf.write(f"// {sig_comp_line}\n")
                else:
                    doc_buf.write(f"// {line}\n")

                fret = m[1].strip()

                fptr = m[2].strip() if m[2] else ""
                fname = m[3].strip()
                fargs = m[4].strip()

                call_args = []
                for a in fargs.split(","):
                    am = re_args.match(a)
                    assert am

                    call_args.append(am[1])
                fcall_args = ", ".join(call_args)

                # print(fret);
                # print(fptr);
                # print(fname);
                # print(fargs)
                # print(fcall_args)

                return {
                    "doc": doc_buf.getvalue(),
                    "ret_type": fret,
                    "ret_ptr": fptr,
                    "func_name": fname,
                    "func_def_args": fargs,
                    "func_call_args": fcall_args,
                    "bad_ret": "NULL" if fptr else "-1",
                }

            sig_comp_line = ""

    assert False, "man parsing failed"


def print_sys_wrapper(func_name):
    man_meta = get_man_page_signature(func_name)
    from string import Template

    templ = Template(TEMPLATE_WRAPPER)
    print(templ.substitute(man_meta))


def check_wrapped_functions(executable):
    assert os.path.exists(executable), "File not exists"

    func_man = subprocess.check_output(("nm", executable))
    man_lines = func_man.decode()
    all_funcs = {}
    wrap_funcs = {}
    for line in man_lines.split("\n"):
        line = line.strip().split(" ")
        if len(line) < 2:
            continue

        f_type = line[-2]
        f_symbol = line[-1]
        if "@" in f_symbol:
            f_symbol = f_symbol.split("@")[0]
        all_funcs[f_symbol] = f_type.upper()
        if f_symbol.startswith("__wrap_"):
            wrap_funcs[f_symbol.replace("__wrap_", "")] = f_type

    has_unwrappable = False
    for wfun in wrap_funcs:
        if wfun not in all_funcs:
            print(
                f"WARNING: missing symbol `{wfun}` for warapper __wrap_{wfun}, not in"
                " symbols table of the executable."
            )
            continue
        if all_funcs[wfun] == "T":
            print(
                f"ERROR: __wrap_{wfun} does not shadow function {wfun}(), symbol"
                " defined in code, not at link time!"
            )
            has_unwrappable = True

    if has_unwrappable:
        print(
            "Some unwrappable symbols found, try to find real function that called, for"
            " example fstat() may call __fxstat"
        )
        sys.exit(1)
    else:
        sys.exit(0)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("src_file")
    parser.add_argument("-o", "--out", action="store_true", default=False)
    parser.add_argument("-i", "--include", default=None, required=False, type=str)
    parser.add_argument("-d", "--data", default=".atestdb", required=False, type=str)
    parser.add_argument("--indent-test", default=4, required=False, type=int)
    parser.add_argument("-w", "--wrap-test", default=False, action="store_true")
    parser.add_argument("-s", "--wrap-sysfunc", default=False, action="store_true")

    args = parser.parse_args()
    src_file = args.src_file

    if args.wrap_test:
        check_wrapped_functions(args.src_file)
    elif args.wrap_sysfunc:
        print_sys_wrapper(args.src_file)
        sys.exit(0)

    source_file_data = {}
    if os.path.exists(args.data):
        with open(args.data, "rb") as fh:
            source_file_data = pickle.load(fh)

    if not os.path.exists(src_file):
        if src_file.endswith(".c"):
            print(
                f"{src_file} not exists, pass file name without extension to create new"
                " test from template"
            )
            sys.exit(1)
        else:
            with open(f"{src_file}.c", "w") as fh:
                fh.write(TEMPLATE)
            sys.exit(0)

    buf = io.StringIO()

    fh = open(src_file, "r")
    lines = fh.readlines()

    all_tests = []
    test_calls = set()

    re_test_definition = re.compile(r"^ATEST_F\((?P<test_name>\w+)\)", re.MULTILINE)
    re_test_setup_f_definition = re.compile(r"^ATEST_SETUP_F\(\w*\)", re.MULTILINE)
    re_parse_main_args = re.compile(r"^\s*ATEST_PARSE_MAINARGS\(.*\);.*", re.MULTILINE)
    re_print_head = re.compile(r"^\s*ATEST_PRINT_HEAD\(.*\);.*", re.MULTILINE)
    re_print_footer = re.compile(r"^\s*ATEST_PRINT_FOOTER\(.*\);.*", re.MULTILINE)
    re_exit_code = re.compile(r"^\s*return\s+ATEST_EXITCODE\(.*\);.*", re.MULTILINE)
    re_verbosity = re.compile(r"\s*(__ATestContext.verbosity) = (\d+);.*", re.MULTILINE)
    re_in_main = re.compile(r".*\s*main\(int\s+argc,\s+char\*\s+argv\[\s*\]\)", re.MULTILINE)
    re_includes_c = re.compile(
        r"^#include\s+\"([.\/\\\w-]+\.(h|hpp|c|cpp))\"", re.MULTILINE
    )

    re_include_test = None
    if args.include:
        re_include_test = re.compile(args.include)
        print(f"Including only pattern: {args.include}")
    has_setup = False
    has_insert_here = False
    has_c_changes = False
    has_return = False
    has_print_head = False
    has_parse_args = False
    has_print_footer = False
    has_exit_code = False
    is_in_main = False
    force_rewrite = False
    insert_indent = ""
    n_tests = 0

    for line in lines:
        # print(l)
        if re_test_definition.match(line):
            all_tests.append(re_test_definition.match(line)["test_name"])
        elif re_test_setup_f_definition.match(line):
            has_setup = True
        elif re_includes_c.search(line):
            m = re_includes_c.search(line)
            fn = m[1]

            abs_path = os.path.abspath(os.path.join(os.path.dirname(src_file), fn))
            mtime = os.path.getmtime(abs_path)
            old_mtime = source_file_data.get(abs_path)

            if not os.path.basename(abs_path).startswith('fake_') and mtime != old_mtime:
                if os.path.exists(args.data):
                    print(f"{abs_path} changed")
                has_c_changes = True

            source_file_data[abs_path] = mtime
        elif "__ATestContext." in line:
            # m = re_verbosity.match(line)
            #
            # if not re_include_test:
            #     if m[2] != "2":
            #         force_rewrite = True
            #     buf.write("    __ATestContext.verbosity = 2; // auto-set by atest\n")
            # else:
            #     if m[2] != "10":
            #         force_rewrite = True
            #     buf.write("    __ATestContext.verbosity = 10; // auto-set by atest\n")
            continue
        elif re_print_head.match(line):
            has_insert_here = True
            has_print_head = True
            buf.write("    ATEST_PRINT_HEAD();  // >>> all tests below\n")
            buf.write("    \n")

            if len(all_tests) == 0:
                print(
                    "Not tests to be inserted, or <ATEST_RUNS> before test definitions"
                )
                sys.exit(1)

            for t in all_tests:
                if re_include_test and not re_include_test.search(t):
                    print(f"Excluding test: {t}")
                    continue
                n_tests += 1
                buf.write(
                    f"    ATEST_RUN({t});\n"
                )
        elif re_print_footer.match(line):
            buf.write("    \n")
            line = "    ATEST_PRINT_FOOTER();  // ^^^^^ all tests runs are above\n"
            has_print_footer = True
            has_insert_here = False
        elif re_exit_code.match(line):
            has_exit_code = True
            has_insert_here = False
        elif re_in_main.match(line):
            is_in_main = True
        elif re_parse_main_args.match(line):
            has_parse_args = True
        elif is_in_main:
            if line.strip().startswith("//"):
                continue
            if not line.strip():
                continue

        if not has_insert_here:
            buf.write(line)

    if not has_parse_args:
        print("No ATEST_PARSE_MAINARGS(...) in main")
        sys.exit(1)
    if not has_exit_code:
        print("No return ATEST_EXITCODE(); in main")
        sys.exit(1)
    if not has_print_footer:
        print("No ATEST_PRINT_FOOTER() found")
        sys.exit(1)
    if not has_print_head:
        print("No ATEST_PRINT_HEAD() found")
        sys.exit(1)
    if not has_setup:
        print("No ATEST_SETUP_F() found")
        sys.exit(1)
    fh.close()

    if not force_rewrite and not has_c_changes and set(all_tests) == set(test_calls):
        # print(f"No changes: {all_tests=} {test_calls=} ")
        # No new tests added or changed, prevent touching the source code then
        sys.exit(0)

    if n_tests == 0:
        print("No tests selected")
        # sys.exit(0)

    if args.out:
        print(buf.getvalue())
    else:
        with open(src_file, "w") as fh:
            fh.write(buf.getvalue())

    data_dir = os.path.dirname(args.data)
    if data_dir:
        os.makedirs(data_dir, exist_ok=True)
    with open(args.data, "wb") as fh:
        pickle.dump(source_file_data, fh)

    sys.exit(0)
