#!/usr/bin/env python3
import argparse
import subprocess
from textwrap import indent, dedent
import os
import shutil
import glob
import sys
import io
import re
import pprint


class CEXEnv:
    def __init__(self):
        self.cli_path = os.path.abspath(__file__)
        self.root = os.path.dirname(self.cli_path)
        self.include_path = os.path.join(self.root, "include")
        self.cex_h_path = os.path.join(self.include_path, "cex.h")
        self.cex_c_path = os.path.join(self.include_path, "cex.c")
        self.fff_h_path = os.path.join(self.include_path, "fff.h")
        self.cex_lib = os.path.join(self.root, "include", "cex")

        assert os.path.exists(self.cli_path)
        assert os.path.exists(self.root)
        assert os.path.exists(self.include_path)
        assert os.path.exists(self.cex_h_path)
        assert os.path.exists(self.cex_c_path)

    def __repr__(self):
        env_vars = {
            "cex_cli": self.cli_path,
            "cex_include": self.include_path,
            "cex_lib": self.cex_lib,
            "cex_c_path": self.cex_c_path,
            "cex_h_path": self.cex_h_path,
            "fff_h_path": self.fff_h_path,
        }
        return pprint.pformat(env_vars)


class CEXTestBuilder:
    TEMPLATE = r"""
    #include <cex.c>

    const Allocator_i* allocator;

    test$teardown(){
        allocator = allocators.heap.destroy(); // this also nullifies allocator
        return EOK;
    }

    test$setup(){
        uassert_enable(); // re-enable if you disabled it in some test case
        allocator = allocators.heap.create();
        return EOK;
    }

    test$case(my_test)
    {
        // Has malloc, but no free(), allocator will send memory leak warning
        void* a = allocator->malloc(100);
        free(a); // free without allocator to keep sanitizer calm

        tassert(true == 1);
        tassert_eqi(1, 1);
        tassert_eql(1, 1L);
        tassert_eqf(1.0, 1.0);
        tassert_eqe(EOK, Error.ok);

        uassert_disable();
        uassert(false && "this will be disabled, no abort!");

        tassertf(true == 0, "true != %d", false);

        // allocator->free(a); // if commented this triggers memory leak warning by allocator

        return EOK;
    }

    int
    main(int argc, char* argv[])
    {
        test$args_parse(argc, argv);
        test$print_header();  // >>> all tests below

        test$run(my_test);

        test$print_footer();  // ^^^^^ all tests runs are above
        return test$exit_code();
    }
    """

    def __init__(
        self, action: str, src_path: str, test_dir: str, force_rebuild: bool = False
    ):
        self.env = CEXEnv()
        self.test_dir = test_dir
        self.src_path = os.path.normpath(src_path)
        self.action = action
        self.include_path_cache = {}
        self.force_rebuild = force_rebuild

        if not os.path.exists(test_dir):
            raise FileNotFoundError(
                f"test_dir={test_dir} not exist in current dir: {os.getcwd()}"
            )

    def search_include_fn(self, incl_fn):
        incl_fn = os.path.normpath(incl_fn)

        if incl_fn not in self.include_path_cache:
            tpath = incl_fn
            if os.path.exists(tpath):
                self.include_path_cache[incl_fn] = tpath
                return tpath

            tpath = os.path.join(self.test_dir, incl_fn)
            if os.path.exists(tpath):
                self.include_path_cache[incl_fn] = tpath
                return tpath

            tpath = os.path.join(os.getcwd(), incl_fn)
            if os.path.exists(tpath):
                self.include_path_cache[incl_fn] = tpath
                return tpath

            tpath = os.path.join(os.getcwd(), "src", incl_fn)
            if os.path.exists(tpath):
                self.include_path_cache[incl_fn] = tpath
                return tpath

            tpath = os.path.join(os.getcwd(), "include", incl_fn)
            if os.path.exists(tpath):
                self.include_path_cache[incl_fn] = tpath
                return tpath

            self.include_path_cache[incl_fn] = None
            return None

        return self.include_path_cache[incl_fn]

    def make_test_exe(self, test_src: str):
        return os.path.join(self.test_dir, "build", test_src + ".test")

    def action_build_test(self, test_src: str):
        test_exe = self.make_test_exe(test_src)
        os.makedirs(os.path.dirname(test_exe), exist_ok=True)

        build_mtime = None
        if os.path.exists(test_exe):
            build_mtime = int(os.path.getmtime(test_exe))

        fh = open(test_src, "r")

        test_mtime = int(os.path.getmtime(test_src))

        lines = fh.readlines()

        all_tests = []

        re_test_definition = re.compile(
            r"^test\$case\((?P<test_name>\w+)\)", re.MULTILINE
        )
        re_test_setup_f_definition = re.compile(r"^test\$setup\(\w*\)", re.MULTILINE)
        re_parse_main_args = re.compile(r"^\s*test\$args_parse\(.*\);.*", re.MULTILINE)
        re_print_head = re.compile(r"^\s*test\$print_header\(.*\);.*", re.MULTILINE)
        re_print_footer = re.compile(r"^\s*test\$print_footer\(.*\);.*", re.MULTILINE)
        re_exit_code = re.compile(
            r"^\s*return\s+test\$exit_code\(.*\);.*", re.MULTILINE
        )
        re_in_main = re.compile(
            r".*\s*main\(int\s+argc,\s+char\*\s+argv\[\s*\]\)", re.MULTILINE
        )
        re_includes_c = re.compile(
            r"^#include\s+[<\"]{1}([.\/\\\w-]+\.[h|c])[>\"]{1}", re.MULTILINE
        )

        has_setup = False
        has_insert_here = False
        has_c_changes = build_mtime is None
        has_print_head = False
        has_parse_args = False
        has_print_footer = False
        has_exit_code = False
        is_in_main = False
        is_in_test_case = False
        n_tests = 0

        buf = io.StringIO()

        for line in lines:
            # print(l)
            if re_test_definition.match(line):
                all_tests.append(re_test_definition.match(line)["test_name"])
                is_in_test_case = True
            elif re_test_setup_f_definition.match(line):
                has_setup = True
            elif re_includes_c.search(line) and not has_c_changes:
                m = re_includes_c.search(line)
                fn = m[1]
                incl_fn = self.search_include_fn(fn)

                if (
                    build_mtime
                    and incl_fn
                    and not os.path.basename(incl_fn).startswith("fake_")
                ):
                    mtime = int(os.path.getmtime(incl_fn))
                    if mtime > build_mtime:
                        print(f"{test_src} changes in {incl_fn}")
                        has_c_changes = True
                    else:
                        if incl_fn.endswith(".c"):
                            alt_h_file = incl_fn[:-2] + ".h"
                        elif incl_fn.endswith(".h"):
                            alt_h_file = incl_fn[:-2] + ".c"
                        else:
                            assert False, f"not implemented extension: {incl_fn}"

                        alt_h_file = self.search_include_fn(alt_h_file)
                        if alt_h_file:
                            mtime = int(os.path.getmtime(alt_h_file))
                            if mtime > build_mtime:
                                # print(f"{test_src} changes in {alt_h_file}")
                                has_c_changes = True

            elif re_print_head.match(line):
                has_insert_here = True
                has_print_head = True
                buf.write("    test$print_header();  // >>> all tests below\n")
                buf.write("    \n")

                if len(all_tests) == 0:
                    print(f"No tests found in {test_src}")
                    return

                for t in all_tests:
                    n_tests += 1
                    buf.write(f"    test$run({t});\n")
            elif re_print_footer.match(line):
                buf.write("    \n")
                line = "    test$print_footer();  // ^^^^^ all tests runs are above\n"
                has_print_footer = True
                has_insert_here = False
            elif re_exit_code.match(line):
                has_exit_code = True
                has_insert_here = False
            elif re_in_main.match(line):
                is_in_main = True
            elif re_parse_main_args.match(line):
                has_parse_args = True
            elif is_in_main:
                if line.strip().startswith("//"):
                    continue
                if not line.strip():
                    continue
            elif is_in_test_case and " return " in line:
                is_in_test_case = False
                line = "    return EOK;\n"
                has_insert_here = False

            if not has_insert_here:
                buf.write(line)

        if not has_parse_args:
            print(f"No test$args_parse(...) in main: {test_src}")
            sys.exit(1)
        if not has_exit_code:
            print(f"No return test$exit_code(); in main: {test_src}")
            sys.exit(1)
        if not has_print_footer:
            print(f"No test$print_footer() found: {test_src}")
            sys.exit(1)
        if not has_print_head:
            print(f"No test$print_header() found: {test_src}")
            sys.exit(1)
        if not has_setup:
            print(f"No test$setup() found: {test_src}")
            sys.exit(1)
        fh.close()

        if not self.force_rebuild and not has_c_changes and test_mtime <= build_mtime:
            # No new tests added or changed, prevent touching the source code then
            # print(f"No changes: {all_tests=} {test_calls=} ")
            return False

        if n_tests == 0:
            print(f"No tests found in: {test_src}")
            return False
        else:
            with open(test_src, "w") as fh:
                fh.write(buf.getvalue())
            return True

    def get_inlined_cc_args(self, test_src: str):
        gcc_args = []
        re_gcc_args = re.compile(r"^//\s*#[g]*cc_args\s+(.*)$", re.MULTILINE)

        with open(test_src, "r") as fh:
            for line in fh.readlines():
                if line.startswith("#include"):
                    break
                g = re_gcc_args.search(line)
                if g:
                    gcc_args.append(g.group(1))
        return gcc_args

    def compile(self, test_src: str):
        assert os.path.exists(test_src)

        gcc_args_inlined = self.get_inlined_cc_args(test_src)

        test_exe = self.make_test_exe(test_src)

        args = [
            "cc",
            "-DCEXTEST",
            "-O0",
            "-g3",
            "-ggdb3",
            "-Wall",
            "-Wextra",
            "-Werror",
            "-Wuninitialized",
            "-Wno-format-overflow",
            "-Wno-unused-function",
            "-Wdouble-promotion",
            "-fsanitize-address-use-after-scope",
            "-fsanitize=address",
            "-fsanitize=undefined",
            "-fsanitize=leak",
            "-fstack-protector-strong",
            f"-I{self.env.include_path}",
            f"-I{self.test_dir}",
        ]

        # src/ and include/ are optional but keep then in gcc include
        src_path = os.path.join(os.getcwd(), "src/")
        if os.path.exists(src_path):
            args.append(f"-I{src_path}")

        include_path = os.path.join(os.getcwd(), "include/")
        if os.path.exists(include_path):
            args.append(f"-I{include_path}")

        if gcc_args_inlined:
            args.extend(gcc_args_inlined)

        args += [
            test_src,
            "-o",
            test_exe,
        ]
        process = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = process.communicate()

        if process.wait(60) != 0:
            print("Process error:")
            print(" ".join(args))
            if gcc_args_inlined:
                print(f"Args inlined:\n{gcc_args_inlined=}")
            print("stdout:")
            print(stdout.decode())
            print("stderr:")
            print(stderr.decode())
            raise RuntimeError(f"Compilation error: {test_src}")

    def action_build(self):
        test_files_list = []

        if self.src_path == "all":
            for fn in glob.glob(
                os.path.join(self.test_dir, "**", "test_*.c"), recursive=True
            ):
                test_files_list.append(fn)
        else:
            assert os.path.exists(self.src_path), f"test not exist: {self.src_path}"
            assert self.src_path.endswith(".c"), "path must end with .c"
            test_files_list.append(self.src_path)

        for fn in test_files_list:
            if self.action_build_test(fn):
                print(f"Building: {fn}")
                self.compile(fn)

    def action_run(self):
        test_exe_list = []

        # Rebuild new before run
        self.action_build()

        if self.src_path == "all":
            for fn in glob.glob(
                os.path.join(self.test_dir, "**", "test_*.c"), recursive=True
            ):
                test_exe_list.append(self.make_test_exe(fn))
        else:
            assert os.path.exists(self.src_path), f"test not exist: {self.src_path}"
            assert self.src_path.endswith(".c"), "path must end with .c"
            test_exe_list.append(self.make_test_exe(self.src_path))

        for fn in test_exe_list:
            args = [
                fn,
            ]

            if self.src_path == "all":
                args.extend(["q"])  # run cex test in quiet mode

            process = subprocess.Popen(
                args,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                # universal_newlines=True,
                # shell=True,
            )
            for line in iter(process.stdout.readline, b""):
                print(line.decode().rstrip())

    def action_clean(self):
        build_dir = os.path.join(self.test_dir, "build")
        if self.src_path == "all":
            if os.path.exists(build_dir):
                shutil.rmtree(build_dir)
        else:
            assert os.path.exists(self.src_path), f"test not exist: {self.src_path}"
            assert self.src_path.endswith(".c"), "path must end with .c"
            test_exe = self.make_test_exe(self.src_path)
            if os.path.exists(test_exe):
                os.unlink(test_exe)

    def action_create(self):
        assert self.src_path != "all", "all not supported for `create` action"
        assert not os.path.exists(self.src_path), f"path already exist: {self.src_path}"
        assert self.src_path.endswith(".c"), "path must end with .c"
        assert os.path.basename(self.src_path).startswith(
            "test_"
        ), "test file name must start with test_ prefix"

        test_file = self.src_path

        if not self.src_path.startswith(self.test_dir):
            test_file = os.path.join(self.test_dir, test_file)

        print(f"making: {test_file}")

        os.makedirs(os.path.dirname(test_file), exist_ok=True)

        with open(test_file, "w") as fh:
            fh.write(dedent(CEXTestBuilder.TEMPLATE))

    def build(self):
        if self.action == "create":
            self.action_create()
        elif self.action == "build":
            self.action_build()
        elif self.action == "clean":
            self.action_clean()
        elif self.action == "run":
            self.action_run()
        else:
            raise ValueError(
                f"Incorrect action: {self.action}, expected one of (build, create, run, clean)"
            )


class CEXBuilder:
    RE_COMMENT_LINE = re.compile(r"^\s*//", re.MULTILINE)
    RE_COMMENT_ML_START = re.compile(r"^\s*\/\*", re.MULTILINE)
    RE_COMMENT_ML_END = re.compile(r".*\*\/", re.MULTILINE)
    RE_CODE_START_LINE = re.compile(r"^[a-zA-Z_0-9\*]+\s+", re.MULTILINE)
    RE_FUNC = re.compile(r"(.*)\s+(\w+)\({1}([\w,\[\]\(\)\s\*\.]+)\)", re.MULTILINE)
    RE_STATIC = re.compile(r"(^static\s|\sstatic\s|\sstatic$)", re.MULTILINE)
    RE_INLINE = re.compile(r"(^inline\s|\sinline\s|\sinline$)", re.MULTILINE)

    class Block:
        """Generic code block

        Attributes:
            buf: code buffer
            line_start: start line of block
            line_end: end line of block
        """

        def __init__(self, line_start: int):
            self.buf = io.StringIO()
            self.line_start = line_start
            self.line_end = None

        def __str__(self):
            return self.__class__.__qualname__

        def __repr__(self):
            return f"Block: {str(self)} [{self.line_start}:{self.line_end}]\n{self.buf.getvalue()}"

        @staticmethod
        def probe(line: str) -> bool:
            """Probes new block type based on line of code"""
            return False

        def process_line(self, line: str) -> bool:
            """Process line of code in initialized block"""
            raise NotImplementedError()

    class Comment(Block):
        """Commentary block

        Attributes:
            comment_type: 'm' - multi line, 's' - single line
        """

        def __init__(self, line_start):
            self.comment_type = None
            super().__init__(line_start)

        def __str__(self):
            return f"Comment({self.comment_type}) [{self.line_start}:{self.line_end}]"

        @staticmethod
        def probe(line: str) -> bool:
            return CEXBuilder.RE_COMMENT_LINE.search(
                line
            ) or CEXBuilder.RE_COMMENT_ML_START.search(line)

        def process_line(self, line: str) -> bool | None:
            if self.comment_type is None:
                if CEXBuilder.RE_COMMENT_ML_START.search(line):
                    self.comment_type = "m"
                elif CEXBuilder.RE_COMMENT_LINE.search(line):
                    self.comment_type = "s"
                else:
                    raise ValueError("Unsupproted commet")

                self.buf.write(line)

                # Single line contains comment end mark
                if CEXBuilder.RE_COMMENT_ML_END.search(line):
                    return False

                return True
            else:
                if self.comment_type == "s":
                    if CEXBuilder.RE_COMMENT_LINE.search(line):
                        self.buf.write(line)
                        return True
                    else:
                        return None  # Unknown line, probe next block
                else:
                    # In multiline comment, write all until end

                    if CEXBuilder.RE_COMMENT_ML_END.search(line):
                        self.buf.write(line.replace("\n", ""))
                        return False  # Block ended
                    else:
                        self.buf.write(line)
                        return True  # Block continues

    class Code(Block):
        """Code block

        Attributes:
            code_type: "func", "var", "struct"
        """

        def __init__(self, line_start):
            self.code_type = None
            self._is_signature = True
            self._brstack = []
            self._brackets: dict = {
                "[": "]",
                "]": None,
                "(": ")",
                ")": None,
                "{": "}",
                "}": None,
            }
            self._comment = None
            super().__init__(line_start)

        def __str__(self):
            return f"Code({self.code_type})[{self.line_start}:{self.line_end}]"

        @staticmethod
        def probe(line: str) -> bool:
            assert not CEXBuilder.RE_COMMENT_LINE.search(line)
            assert not CEXBuilder.RE_COMMENT_ML_START.search(line)
            return CEXBuilder.RE_CODE_START_LINE.search(line)

        def process_brackets(self, c: str):
            assert len(c) == 1
            assert c in self._brackets
            if not self._brstack:
                assert (
                    self._brackets[c] is not None
                ), f"Must me opening bracket: c={c}\n{self.buf.getvalue()}"
                self._brstack.append(c)
            else:
                if self._brackets[self._brstack[-1]] == c:
                    # c is closing bracket
                    self._brstack.pop(-1)
                else:
                    # new bracket level
                    assert (
                        self._brackets[c] is not None
                    ), f"Must me opening bracket: c={c}\n{self.buf.getvalue()}"
                    self._brstack.append(c)
            pass

        def process_line(self, line: str) -> bool | None:
            if not self._comment:
                if CEXBuilder.Comment.probe(line):
                    self._comment = CEXBuilder.Comment(-1)
                    if not self._comment.process_line(line):
                        self._comment = None
                    return True
            else:
                cmt = self._comment.process_line(line)
                if cmt:
                    return True
                else:
                    self._comment = None
                    if cmt is not None:
                        return True

            for c in line.strip():
                # We are in signature
                if self._is_signature:
                    # Decide definition type based on signature
                    if c in self._brackets:

                        if c == "(":
                            self.code_type = "func"
                        elif c == "{":
                            assert (
                                not self._brstack
                            ), f"No all brackets closed: {self._brstack}"
                            # Function signature is completed, started implementation
                            self._is_signature = False
                            if self.code_type is None:
                                if "struct " in self.buf.getvalue():
                                    self.code_type = "struct"

                        self.process_brackets(c)
                    elif c == "=":
                        self.code_type = "var"
                    elif c == ";":
                        # Reached the end while in signature
                        # assert self.code_type == "func", f"{self.code_type}"
                        if self.code_type is None:
                            if "extern " in self.buf.getvalue():
                                self.code_type = "var"
                        if self.code_type == "func":
                            if "typedef " in self.buf.getvalue():
                                self.code_type = "type"
                            else:
                                self.code_type = "decl"
                        # Return block end
                        return False

                    if self._is_signature:
                        self.buf.write(c)
                else:

                    if c in self._brackets:
                        self.process_brackets(c)

                    if len(self._brstack) == 0:

                        # Handle last closing bracket of a function
                        if self.code_type == "func":
                            if c == "}":
                                return False
                        elif self.code_type == "var":
                            if c == ";":
                                return False
                        else:
                            if c == ";":
                                return False

                    pass

            if self._is_signature:
                self.buf.write(" ")
            return True

    class Func:
        """Function metadata

        Attributes:
            is_static: function defined as static
            is_inline: function defined as inline
            typedef: function type definition part
            name: function full name
            args: function full arguments
            docstr: comment block prior function
            sub_module: function sub module, typically _<namespace>__<sub_module>__<name>
            ifc_name: function interface short name
        """

        def __init__(self, decl: str, ifc_prefix: str):
            g = CEXBuilder.RE_FUNC.match(decl)
            assert g, f"Function regex not matched: {decl}"
            self.is_static = False
            self.is_inline = False
            typedef = g.group(1)

            if CEXBuilder.RE_STATIC.search(typedef):
                self.is_static = True
                typedef = CEXBuilder.RE_STATIC.sub(" ", typedef)
            if CEXBuilder.RE_INLINE.search(typedef):
                self.is_inline = True
                typedef = CEXBuilder.RE_INLINE.sub(" ", typedef)

            self.ifc_prefix = ifc_prefix
            self.typedef = typedef.strip()
            self.name = g.group(2).strip()
            self.args = g.group(3).strip()

            self.args = self.args.replace(" restrict ", " ")
            self.docstr = ""

            g = re.match(rf"^{ifc_prefix}__([\w]+)__(\w+)", self.name, re.MULTILINE)
            if g:
                self.sub_module = g.group(1)
                self.ifc_name = g.group(2)
                assert self.ifc_name
            elif g := re.match(rf"^{ifc_prefix}_(\w+)", self.name, re.MULTILINE):
                self.sub_module = None
                self.ifc_name = g.group(1)
                assert self.ifc_name
            else:
                # Not in namespace
                self.ifc_name = None
                self.sub_module = None

            assert (
                "(" not in self.typedef and ")" not in self.typedef
            ), f"function pointers?? {self}"

        @property
        def is_public_cex(self) -> bool:
            if self.is_inline and self.is_static:
                return False

            g = re.match(
                rf"^{self.ifc_prefix}__([\w]+)__(\w+)", self.name, re.MULTILINE
            )
            if not g and f"{self.ifc_prefix}__" in self.name:
                # private function, and not second level namespace
                return False

            return True

        def to_pointer_decl(self, indent: bool) -> str:
            """Function declaration for .h struct

            Args:
                indent: indent type def and name

            Returns:

            """
            assert self.ifc_name, "not in namespace"

            if indent:
                return f"{self.typedef}\n(*{self.ifc_name})({self.args});\n"
            else:
                return f"{self.typedef} (*{self.ifc_name})({self.args});\n"

        def to_pointer_def(self) -> str:
            """Function .c struct field definition"""
            assert self.ifc_name, "not in namespace"

            return f"    .{self.ifc_name} = {self.name},"

        def __repr__(self):
            return f"""
    Function:
        typedef: {self.typedef}
        is_static: {self.is_static}
        is_inline: {self.is_inline}
        name: {self.name}
        args: {self.args}
        """

    def __init__(self, c_file: str, h_file: str, namespace: str = None):
        """CEX Module generator initializer

        Args:
            c_file: path to .c file
            h_file: path to .h file
            namespace:
        """
        assert h_file.endswith(".h")
        self.h_file = h_file

        if c_file:
            assert c_file.endswith(".c")
            self.c_file = c_file
            assert os.path.basename(c_file.replace(".c", "")) == os.path.basename(
                h_file.replace(".h", "")
            ), f"BaseName of {c_file=} and {h_file=} mismatch"
            self.is_public_header = False
        else:
            self.is_public_header = True
            self.c_file = None

        if namespace:
            self.namespace = namespace
        else:
            self.namespace = os.path.basename(self.h_file).replace(".h", "")

        ns = self.namespace
        if self.is_public_header:
            self.ns_struct_name = f"__header__{ns}"
        else:
            if ns == ns.lower():
                self.ns_struct_name = f"__module__{ns}"
            else:
                self.ns_struct_name = f"__class__{ns}"

    @staticmethod
    def block_probe(line: str, lineno: int) -> Block | None:
        """Probed block type"""
        if CEXBuilder.Comment.probe(line):
            return CEXBuilder.Comment(lineno)
        if CEXBuilder.Code.probe(line):
            return CEXBuilder.Code(lineno)
        return None

    def parse_source(self, c_file) -> tuple[list[str], list[Block]]:
        """Parses source for lines and list of Blocks"""
        assert os.path.exists(c_file), f"File not exists: {c_file}"

        with open(c_file, "r") as fh:
            lines = fh.readlines()

        blocks = []
        current_block: CEXBuilder.Block | None = None
        for i, line in enumerate(lines):
            while True:
                if current_block is None:
                    current_block = self.block_probe(line, i)

                if current_block:
                    lres = current_block.process_line(line)
                    if not lres:
                        # block ended at this line
                        blocks.append(current_block)
                        # print(repr(current_block))

                        if lres is None:
                            # previous block demanded next probe, at current line!
                            current_block.line_end = i - 1
                            current_block = None
                            continue
                        else:
                            current_block.line_end = i
                            current_block = None
                # process next source line
                break

        return lines, blocks

    def is_func_code(self, block: Code):
        isinstance(block, CEXBuilder.Code)

        if self.is_public_header:
            if block.code_type == "decl":
                return True
        else:
            if block.code_type == "func":
                return True
        return False

    def make_interface_declaration(self, blocks: list[Block]):
        """Generates CEX interface declaration in .h file"""
        ns = self.namespace
        ns_struct_name = self.ns_struct_name
        ifc_contents = []
        ifc_contents.append(f"struct {ns_struct_name}")
        ifc_contents.append("{")
        ifc_contents.append("    // Autogenerated by CEX")
        ifc_contents.append("    // clang-format off\n")
        functions: dict[str | None, list[CEXBuilder.Func]] = {}
        for i, b in enumerate(blocks):

            # print(repr(b))
            if isinstance(b, CEXBuilder.Code):
                if self.is_func_code(b):
                    f = CEXBuilder.Func(b.buf.getvalue(), ns)
                    if f.ifc_name and f.is_public_cex:
                        if i > 0 and isinstance(blocks[i - 1], CEXBuilder.Comment):
                            f.docstr = blocks[i - 1].buf.getvalue()
                        flist = functions.setdefault(f.sub_module, [])
                        flist.append(f)

        assert (
            functions
        ), f"No functions passed module filter, expected prefix: {self.namespace}_"

        for sub_module, flist in functions.items():
            if sub_module:
                ifc_contents.append(f"\nstruct {{  // sub-module .{sub_module} >>>")

            def dd(txt):
                return indent(txt, "    ") if sub_module else txt

            for func in flist:
                if func.docstr:
                    ifc_contents.append(dd(func.docstr))
                ifc_contents.append(dd(func.to_pointer_decl(indent=True)))

            if sub_module:
                ifc_contents.append(
                    f"}} {sub_module};  // sub-module .{sub_module} <<<"
                )
            pass

        ifc_contents.append("    // clang-format on")
        if not self.is_public_header:
            ifc_contents.append("};")
            # NOTE: need extra line for endif handling
            # Algo, no empty lines should be between declaration and extern,
            #  because empty line remains and stacking at consequent calls
            ifc_contents.append(
                f"extern const struct {ns_struct_name} {ns}; // CEX Autogen\n"
            )
        else:
            # NOTE: need extra line for endif handling
            ifc_contents.append("};\n")

        return ifc_contents

    def make_interface_definition(self, blocks: list[Block]):
        """Generates CEX interface definition (in .c file)"""
        ns = self.namespace
        ns_struct_name = self.ns_struct_name

        ifc_contents = []
        ifc_contents.append(f"const struct {ns_struct_name} {ns} = {{")
        ifc_contents.append("    // Autogenerated by CEX")
        ifc_contents.append("    // clang-format off")
        functions: dict[str | None, list[CEXBuilder.Func]] = {}
        for i, b in enumerate(blocks):
            if isinstance(b, CEXBuilder.Code):
                if self.is_func_code(b):
                    f = CEXBuilder.Func(b.buf.getvalue(), ns)
                    if f.ifc_name and f.is_public_cex:
                        if f.is_inline and not f.is_static:
                            raise ValueError(
                                f"Function: {f.name} must be have static with inline"
                            )
                        if i > 0 and isinstance(blocks[i - 1], CEXBuilder.Comment):
                            f.docstr = blocks[i - 1].buf.getvalue()
                        flist = functions.setdefault(f.sub_module, [])
                        flist.append(f)

        assert functions, "No functions passed module filter"

        for sub_module, flist in functions.items():
            if sub_module:
                ifc_contents.append(
                    f"\n    .{sub_module} = {{  // sub-module .{sub_module} >>>"
                )

            def dd(txt):
                return indent(txt, "    ") if sub_module else txt

            for func in flist:
                ifc_contents.append(dd(func.to_pointer_def()))

            if sub_module:
                ifc_contents.append(f"    }},  // sub-module .{sub_module} <<<")
            pass

        ifc_contents.append("    // clang-format on")
        ifc_contents.append("};")

        return ifc_contents

    def clean_old_struct_code(
        self, src_lines: list[str], src_blocks: list[Block]
    ) -> int:
        """Cleans old source from previews CEX declarations/definitions"""
        existing = []
        last_ifndef = None
        for b in src_blocks:
            if isinstance(b, CEXBuilder.Code) and b.code_type in ["var", "struct"]:
                code_line = b.buf.getvalue()
                if self.ns_struct_name in code_line:
                    existing.append(b)

        for b in reversed(existing):
            # print(f"exists at: {b}")
            del src_lines[int(b.line_start) : int(b.line_end) + 1]

        for i, line in enumerate(reversed(src_lines)):
            if line.strip() == "":
                continue
            # Check #endif guard
            if line.strip().startswith("#endif"):
                last_ifndef = len(src_lines) - i - 1
            break
        return last_ifndef

    def make_fff_fake(
        self, fake_dir: str, h_file: str, blocks: list[Block], sub_module: str = ""
    ):
        assert os.path.exists(fake_dir), f"{fake_dir} not exists"

        if h_file.startswith("./"):
            h_file = h_file[2:]

        src = io.StringIO()
        src_reset = io.StringIO()
        src_wrap = io.StringIO()
        src_wrap_reset = io.StringIO()
        src.write("// Autogenerated <fff.h> mocks\n")
        src.write("// NOTE: Do not edit, all changes can be lost\n")
        src.write("\n// clang-format off\n")
        src.write("#include <fff.h>\n")
        src.write(f"#include <{h_file}>\n\n")
        src_wrap.write(src.getvalue())
        src_wrap.write(
            "// IMPORTANT: wrapping works only with gcc  `-Wl,--wrap=Shmem_new,--wrap=Protocol_event_emitter_new`  flag"
        )
        fake_count = 0

        _RE_COMBINE_WHITESPACE = re.compile(r"\s+")

        file = h_file
        base_file = "fake__" + file.replace("../", "").replace("include/", "").replace(
            "src/", ""
        ).replace("/", "__")

        if sub_module:
            base_file = base_file.replace(".h", f"__{sub_module}.h")

        wrap_fake = base_file.replace(".h", "__wrap.h")

        src_reset.write("\n// clang-format off\n")
        src_wrap_reset.write("\n// clang-format off\n")
        src_reset.write(
            f"\n\nstatic void {base_file.replace('.h', '__resetall(void) {')}\n"
        )
        src_wrap_reset.write(
            f"\n\nstatic void {wrap_fake.replace('.h', '__resetall(void) {')}\n"
        )

        for block in blocks:
            if not isinstance(block, CEXBuilder.Code) or not self.is_func_code(block):
                continue

            f = CEXBuilder.Func(block.buf.getvalue(), "")
            if not f.is_public_cex:
                continue

            is_var_args = False

            sig_args = []
            fargs = f.args.split(",")
            for a in fargs:
                # make argument string exactly 1 space separated
                a = _RE_COMBINE_WHITESPACE.sub(" ", a).strip()

                subargs = a.split(" ")
                if "[" in subargs[-1]:
                    subargs[-1] = "*"
                elif "..." == subargs[-1]:
                    is_var_args = True
                else:
                    del subargs[-1]

                a = " ".join(subargs)
                if a:
                    sig_args.append(a)
            fake_count += 1

            # print(sig_args)
            sig_args_prefix = ", " if sig_args else ""
            src.write("\n")
            src_wrap.write("\n")
            var_arg_prefix = "_VARARG" if is_var_args else ""

            if f.typedef.strip() == "void":
                src.write(
                    f"FAKE_VOID_FUNC{var_arg_prefix}({f.name}{sig_args_prefix}{', '.join(sig_args)})"
                )
                src_wrap.write(
                    f"FAKE_VOID_FUNC{var_arg_prefix}(__wrap_{f.name}{sig_args_prefix}{', '.join(sig_args)})"
                )
                src_wrap.write(f"void __real_{f.name}({', '.join(sig_args)});\n")
            else:
                ret_val = f.typedef
                ret_val = ret_val.replace("UErr_exc", "UErr_e")
                ret_val = ret_val.replace("Exception", "Exc")
                ret_val = ret_val.replace("ExcSkip", "Exc")
                src.write(
                    f"FAKE_VALUE_FUNC{var_arg_prefix}({ret_val}, {f.name}{sig_args_prefix}{', '.join(sig_args)})"
                )
                src_wrap.write(
                    f"FAKE_VALUE_FUNC{var_arg_prefix}({ret_val}, __wrap_{f.name}{sig_args_prefix}{', '.join(sig_args)})"
                )
                src_wrap.write(f"{f.typedef} __real_{f.name}({', '.join(sig_args)});\n")

            src_reset.write(f"    RESET_FAKE({f.name})\n")
            src_wrap_reset.write(f"    RESET_FAKE(__wrap_{f.name})\n")

        src.write("\n\n")
        src_wrap.write("\n\n")

        src_reset.write("}\n\n")
        src_wrap_reset.write("}\n\n")

        if not self.is_public_header:
            c_ifc_impl = self.make_interface_definition(blocks)
            src.write("\n".join(c_ifc_impl))
            src_wrap.write("\n".join(c_ifc_impl))

        with open(os.path.join(fake_dir, base_file), "w") as fh:
            fh.write(src.getvalue())
            fh.write(src_reset.getvalue())

        if not sub_module:
            with open(os.path.join(fake_dir, wrap_fake), "w") as fh:
                fh.write(src_wrap.getvalue())
                fh.write(src_wrap_reset.getvalue())

    def build(self, fake_dir):
        """Build CEX module"""
        c_lines, c_blocks = self.parse_source(c_file)
        h_lines, h_blocks = self.parse_source(h_file)

        ifc_decl = self.make_interface_declaration(c_blocks)
        ifc_def = self.make_interface_definition(c_blocks)

        self.clean_old_struct_code(c_lines, c_blocks)
        endif_guard = self.clean_old_struct_code(h_lines, h_blocks)

        if endif_guard:
            # ifc_decl.append('\n')
            h_lines.insert(endif_guard, "\n".join(ifc_decl))
        else:
            h_lines.append("\n".join(ifc_decl))
        c_lines.append("\n".join(ifc_def))

        with open(self.c_file, "w") as fh:
            fh.writelines(c_lines)
        with open(self.h_file, "w") as fh:
            fh.writelines(h_lines)

        if fake_dir:
            self.make_fff_fake(fake_dir, h_file, c_blocks)

    def build_header(self, fake_dir):
        """Build CEX module"""
        h_lines, h_blocks = self.parse_source(h_file)

        ifc_decl = self.make_interface_declaration(h_blocks)
        ifc_def = self.make_interface_definition(h_blocks)

        self.clean_old_struct_code(h_lines, h_blocks)
        endif_guard = self.clean_old_struct_code(h_lines, h_blocks)

        if endif_guard:
            h_lines.insert(endif_guard, "\n".join(ifc_decl))
        else:
            h_lines.append("\n".join(ifc_decl))
        h_lines.append("\n".join(ifc_def))

        # print("\n".join(h_lines))
        with open(self.h_file, "w") as fh:
            fh.writelines(h_lines)

        if fake_dir:

            # Make fake for whole app
            self.make_fff_fake(fake_dir, h_file, h_blocks, "")

            sub_module_blocks = {}

            for block in h_blocks:
                if not isinstance(block, CEXBuilder.Code) or not self.is_func_code(
                    block
                ):
                    continue

                f = CEXBuilder.Func(block.buf.getvalue(), self.namespace)
                if not f.is_public_cex:
                    continue
                sub_mod = f.sub_module if f.sub_module else ""
                flist = sub_module_blocks.setdefault(sub_mod, [])
                flist.append(block)

            # Make fake for individual sub modules
            for sub_mod, funcs_blocks in sub_module_blocks.items():
                if not sub_mod.strip():
                    sub_mod = "unknown"
                self.make_fff_fake(fake_dir, h_file, funcs_blocks, sub_mod)


def action_test(args):
    builder = CEXTestBuilder(
        args.action,
        src_path=args.test_file,
        test_dir=args.testdir,
        force_rebuild=args.force,
    )
    builder.build()


def action_env(args):
    env = CEXEnv()
    print(repr(env))


def action_make(args):
    print(f"action_make: {args}")
    return
    if args.source_file.endswith(".c"):
        c_file = args.source_path
        h_file = args.source_path.replace(".c", ".h")
    else:
        assert args.source_path.endswith(".h")
        h_file = args.source_path
        c_file = None

    # TODO: add batch mode (when passing directory)

    builder = CEXBuilder(c_file, h_file, namespace=args.namespace)
    if builder.is_public_header:
        builder.build_header(args.fakedir)
    else:
        builder.build(args.fakedir)

    print(f"CEX done for: {args.source_file}")


if __name__ == "__main__":
    global_parser = argparse.ArgumentParser()
    subparsers = global_parser.add_subparsers(
        required=True, title="subcommands", help="CEX operations"
    )

    make_parser = subparsers.add_parser(
        "make", help="tranforms source code into CEX namespace"
    )
    make_parser.add_argument(
        "source_path",
        help="Directory (batch mode), or file path .c (code mode) or .h (lib mode)",
    )
    make_parser.add_argument("--fakedir", help="fff.h fake directory", default="")
    make_parser.add_argument(
        "--namespace",
        help="module/class namespace, inferred from file name",
        default=None,
    )
    make_parser.set_defaults(func=action_make)

    test_parser = subparsers.add_parser("test", help="CEX test manager runner")
    test_parser.add_argument(
        "action", help="test action {create, run, build, debug, clean}"
    )
    test_parser.add_argument(
        "-d", "--testdir", help="Root directory of tests", default="tests"
    )
    test_parser.add_argument(
        "-f",
        "--force",
        help="Force test rebuild befor command",
        default=False,
        action="store_true",
    )
    test_parser.add_argument("test_file", help="File path to cex test .c file")
    test_parser.set_defaults(func=action_test)

    env_parser = subparsers.add_parser(
        "env", help="CEX environment variables / diagnostics"
    )
    env_parser.set_defaults(func=action_env)

    cli_arguments = global_parser.parse_args()
    cli_arguments.func(cli_arguments)
