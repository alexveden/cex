#!/usr/bin/env python3
import argparse
import json
import shlex
import subprocess
from textwrap import indent, dedent
import os
import shutil
import glob
import sys
import io
import re
import pprint


class CEXEnv:
    def __init__(self):
        self.cli_path = os.path.abspath(__file__)
        self.root = os.path.dirname(self.cli_path)
        self.include_path = os.path.join(self.root, "include")
        self.cex_h_path = os.path.join(self.include_path, "cex.h")
        self.cex_c_path = os.path.join(self.include_path, "cex.c")
        self.fff_h_path = os.path.join(self.include_path, "fff.h")
        self.cex_lib = os.path.join(self.root, "include", "cex")

        assert os.path.exists(self.cli_path)
        assert os.path.exists(self.root)
        assert os.path.exists(self.include_path)
        assert os.path.exists(self.cex_h_path)
        assert os.path.exists(self.cex_c_path)

    def get_project_root(self):
        cwd = os.getcwd()

        def p(path):
            return os.path.exists(os.path.join(cwd, path))

        score = 0
        score += p(".git")
        score += p(".clangd")
        score += p(".clang-format")
        score += p(".gitignore")
        score += p("Makefile")
        score += p("tests")
        score += p("src")
        score += p("include")

        if score < 3:
            raise FileNotFoundError(f"{cwd} does not look as project root dir")

        return cwd

    def __repr__(self):
        try:
            proj_root = self.get_project_root()
        except Exception as exc:
            proj_root = repr(exc)

        env_vars = {
            "cex_cli": self.cli_path,
            "cex_include": self.include_path,
            "cex_lib": self.cex_lib,
            "cex_c_path": self.cex_c_path,
            "cex_h_path": self.cex_h_path,
            "fff_h_path": self.fff_h_path,
            "proj_root": proj_root,
        }
        return pprint.pformat(env_vars)


class CEXCompiler:
    def __init__(self):
        self.env = CEXEnv()

    def process_dep_args(self, dep: str):
        args = [
            "pkg-config",
        ]
        assert "--cflags" not in dep, f"--cflags not allowed in {dep}"
        assert "--libs" not in dep, f"--libs not allowed in {dep}"

        lib_args = shlex.split(dep.strip())
        argscc = args.copy() + ["--cflags"] + lib_args

        process = subprocess.Popen(
            argscc, stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )
        stdout, stderr = process.communicate()

        if process.wait(300) != 0:
            print(dep)
            print(" ".join(argscc))
            print("stdout:")
            print(stdout.decode())
            print("stderr:")
            print(stderr.decode())
            raise RuntimeError("#dep_args --cflags command error")

        argslib = args.copy() + ["--libs"] + lib_args
        cc_args = shlex.split(stdout.decode())

        process = subprocess.Popen(
            argslib, stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )
        stdout, stderr = process.communicate()

        if process.wait(300) != 0:
            print(dep)
            print(" ".join(argslib))
            print("stdout:")
            print(stdout.decode())
            print("stderr:")
            print(stderr.decode())
            raise RuntimeError("#dep_args --libs command error")

        lib_args = shlex.split(stdout.decode())

        return cc_args, lib_args

    def get_inlined_cc_args(self, test_src: str) -> tuple[list, list]:
        """Get compiler/linker args inlined into main.c / test_.c file

        Args:
            test_src: main source code

        Returns: list[cc_args], list[ld_args]
        """
        cc_args = []
        ld_args = []
        dep_args = []
        re_cc_args = re.compile(r"^//\s*#cc_args\s+(.*)$", re.MULTILINE)
        re_ld_args = re.compile(r"^//\s*#ld_args\s+(.*)$", re.MULTILINE)
        re_dep_args = re.compile(r"^//\s*#dep_args\s+(.*)$", re.MULTILINE)

        with open(test_src, "r") as fh:
            for line in fh.readlines():
                if line.startswith("#include"):
                    break
                g = re_cc_args.search(line)
                if g:
                    cc_args.append(g.group(1))

                g = re_ld_args.search(line)
                if g:
                    ld_args.append(g.group(1))

                g = re_dep_args.search(line)
                if g:
                    try:
                        d = g.group(1)
                        _c, _l = self.process_dep_args(d)
                        cc_args.extend(_c)
                        ld_args.extend(_l)
                        dep_args.append(d)
                    except Exception:
                        print(f"Error processing {line}")
                        raise

        return cc_args, ld_args, dep_args

    def update_compile_db(self, src_path: str, cc_args: list[str]):
        proj_root = self.env.get_project_root()
        j = {
            "directory": proj_root,
            "file": src_path,
            "arguments": cc_args,
        }
        jdata = [j]

        if os.path.exists(os.path.join(proj_root, "compile_commands.json")):
            with open(os.path.join(proj_root, "compile_commands.json"), "r") as fh:
                jdata = json.load(fh)

            is_found = False
            for i, r in enumerate(jdata):
                if r.get("directory") == proj_root and r.get("file") == src_path:
                    # print(f"Updated update_compile_db: {src_path}")
                    jdata[i] = j
                    is_found = True
                    break
            if not is_found:
                jdata.append(j)

        with open(os.path.join(proj_root, "compile_commands.json"), "w") as fh:
            json.dump(jdata, fh, indent=4)
        pass

    def compile_app(
        self,
        src_path: str,
        out_file: str,
        compiler_args: list[str] = None,
        linker_args: list[str] = None,
    ):
        assert os.path.exists(src_path)

        cc_args_inlined, ld_args_inlined, dep_args_inlined = self.get_inlined_cc_args(
            src_path
        )

        args = [
            "cc",
            # "clang",
            "-Wall",
            "-Wextra",
            "-Werror",
            # "-fwhole-program",
            f"-I{self.env.include_path}",
        ]

        # src/ and include/ are optional but keep then in gcc include
        src_incl_path = os.path.join(os.getcwd(), "src/")
        if os.path.exists(src_incl_path):
            args.append(f"-I{src_incl_path}")

        include_path = os.path.join(os.getcwd(), "include/")
        if os.path.exists(include_path):
            args.append(f"-I{include_path}")

        if compiler_args:
            args.extend(compiler_args)

        # args.append(src_path)

        if cc_args_inlined:
            args.extend(cc_args_inlined)

        args += [
            src_path,
            "-o",
            out_file,
        ]

        if linker_args:
            args.extend(linker_args)

        if ld_args_inlined:
            args.extend(ld_args_inlined)

        process = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = process.communicate()

        if process.wait(300) != 0:
            print("Process error:")
            print(" ".join(args))
            if cc_args_inlined:
                print(f"CC args inlined:\n{cc_args_inlined=}")
            if compiler_args:
                print(f"CC args passed:\n{compiler_args=}")
            if ld_args_inlined:
                print(f"LD args inlined:\n{ld_args_inlined=}")
            if linker_args:
                print(f"LD args passed:\n{linker_args=}")
            if dep_args_inlined:
                print(f"Dependency args inlined:\n{dep_args_inlined=}")
            print("stdout:")
            print(stdout.decode())
            print("stderr:")
            print(stderr.decode())
            print(f"Compilation error: {src_path}")
            sys.exit(1)

        self.update_compile_db(src_path, args)

    pass


class CEXTestBuilder:
    TEMPLATE = r"""
    #include <cex.c>

    const Allocator_i* allocator;

    test$teardown(){
        allocator = allocators.heap.destroy(); // this also nullifies allocator
        return EOK;
    }

    test$setup(){
        uassert_enable(); // re-enable if you disabled it in some test case
        allocator = allocators.heap.create();
        return EOK;
    }

    test$case(my_test)
    {
        // Has malloc, but no free(), allocator will send memory leak warning
        void* a = allocator->malloc(100);
        free(a); // free without allocator to keep sanitizer calm

        tassert(true == 1);
        tassert_eqi(1, 1);
        tassert_eql(1, 1L);
        tassert_eqf(1.0, 1.0);
        tassert_eqe(EOK, Error.ok);

        uassert_disable();
        uassert(false && "this will be disabled, no abort!");

        tassertf(true == 0, "true != %d", false);

        // allocator->free(a); // this triggers memory leak warning by allocator

        return EOK;
    }

    int
    main(int argc, char* argv[])
    {
        test$args_parse(argc, argv);
        test$print_header();  // >>> all tests below

        test$run(my_test);

        test$print_footer();  // ^^^^^ all tests runs are above
        return test$exit_code();
    }
    """

    def __init__(
        self,
        action: str,
        src_path: str,
        test_dir: str,
        force_rebuild: bool = False,
        ccargs: str = None,
        ldargs: str = None,
    ):
        self.env = CEXEnv()
        self.test_dir = test_dir
        self.src_path = os.path.normpath(src_path)
        self.action = action
        self.include_path_cache = {}
        self.force_rebuild = force_rebuild
        self.ccargs = [] if not ccargs else shlex.split(ccargs)
        self.ldargs = [] if not ldargs else shlex.split(ldargs)
        self.compiler = CEXCompiler()

        if not os.path.exists(test_dir):
            raise FileNotFoundError(
                f"test_dir={test_dir} not exist in current dir: {os.getcwd()}"
            )

    def search_include_fn(self, incl_fn):
        incl_fn = os.path.normpath(incl_fn)

        if incl_fn not in self.include_path_cache:
            tpath = incl_fn
            if os.path.exists(tpath):
                self.include_path_cache[incl_fn] = tpath
                return tpath

            tpath = os.path.join(self.test_dir, incl_fn)
            if os.path.exists(tpath):
                self.include_path_cache[incl_fn] = tpath
                return tpath

            tpath = os.path.join(os.getcwd(), incl_fn)
            if os.path.exists(tpath):
                self.include_path_cache[incl_fn] = tpath
                return tpath

            tpath = os.path.join(os.getcwd(), "src", incl_fn)
            if os.path.exists(tpath):
                self.include_path_cache[incl_fn] = tpath
                return tpath

            tpath = os.path.join(os.getcwd(), "include", incl_fn)
            if os.path.exists(tpath):
                self.include_path_cache[incl_fn] = tpath
                return tpath

            self.include_path_cache[incl_fn] = None
            return None

        return self.include_path_cache[incl_fn]

    def make_test_exe(self, test_src: str):
        return os.path.join(self.test_dir, "build", test_src + ".test")

    def action_build_test(self, test_src: str):
        test_exe = self.make_test_exe(test_src)
        os.makedirs(os.path.dirname(test_exe), exist_ok=True)

        build_mtime = None
        if os.path.exists(test_exe):
            build_mtime = int(os.path.getmtime(test_exe))

        fh = open(test_src, "r")

        test_mtime = int(os.path.getmtime(test_src))

        lines = fh.readlines()

        all_tests = []

        re_test_definition = re.compile(
            r"^test\$case\((?P<test_name>\w+)\)", re.MULTILINE
        )
        re_test_setup_f_definition = re.compile(r"^test\$setup\(\w*\)", re.MULTILINE)
        re_parse_main_args = re.compile(r"^\s*test\$args_parse\(.*\);.*", re.MULTILINE)
        re_print_head = re.compile(r"^\s*test\$print_header\(.*\);.*", re.MULTILINE)
        re_print_footer = re.compile(r"^\s*test\$print_footer\(.*\);.*", re.MULTILINE)
        re_exit_code = re.compile(
            r"^\s*return\s+test\$exit_code\(.*\);.*", re.MULTILINE
        )
        re_in_main = re.compile(
            r".*\s*main\(int\s+argc,\s+char\*\s+argv\[\s*\]\)", re.MULTILINE
        )
        re_includes_c = re.compile(
            r"^#include\s+[<\"]{1}([.\/\\\w-]+\.[h|c])[>\"]{1}", re.MULTILINE
        )

        has_setup = False
        has_insert_here = False
        has_c_changes = build_mtime is None
        has_print_head = False
        has_parse_args = False
        has_print_footer = False
        has_exit_code = False
        is_in_main = False
        is_in_test_case = False
        n_tests = 0

        buf = io.StringIO()

        for line in lines:
            # print(l)
            if re_test_definition.match(line):
                all_tests.append(re_test_definition.match(line)["test_name"])
                is_in_test_case = True
            elif re_test_setup_f_definition.match(line):
                has_setup = True
            elif re_includes_c.search(line) and not has_c_changes:
                m = re_includes_c.search(line)
                fn = m[1]
                incl_fn = self.search_include_fn(fn)

                if (
                    build_mtime
                    and incl_fn
                    and not os.path.basename(incl_fn).startswith("fake_")
                ):
                    mtime = int(os.path.getmtime(incl_fn))
                    if mtime > build_mtime:
                        print(f"{test_src} changes in {incl_fn}")
                        has_c_changes = True
                    else:
                        if incl_fn.endswith(".c"):
                            alt_h_file = incl_fn[:-2] + ".h"
                        elif incl_fn.endswith(".h"):
                            alt_h_file = incl_fn[:-2] + ".c"
                        else:
                            assert False, f"not implemented extension: {incl_fn}"

                        alt_h_file = self.search_include_fn(alt_h_file)
                        if alt_h_file:
                            mtime = int(os.path.getmtime(alt_h_file))
                            if mtime > build_mtime:
                                # print(f"{test_src} changes in {alt_h_file}")
                                has_c_changes = True

            elif re_print_head.match(line):
                has_insert_here = True
                has_print_head = True
                buf.write("    test$print_header();  // >>> all tests below\n")
                buf.write("    \n")

                if len(all_tests) == 0:
                    print(f"No tests found in {test_src}")
                    return

                for t in all_tests:
                    n_tests += 1
                    buf.write(f"    test$run({t});\n")
            elif re_print_footer.match(line):
                buf.write("    \n")
                line = "    test$print_footer();  // ^^^^^ all tests runs are above\n"
                has_print_footer = True
                has_insert_here = False
            elif re_exit_code.match(line):
                has_exit_code = True
                has_insert_here = False
            elif re_in_main.match(line):
                is_in_main = True
            elif re_parse_main_args.match(line):
                has_parse_args = True
            elif is_in_main:
                if line.strip().startswith("//"):
                    continue
                if not line.strip():
                    continue
            elif is_in_test_case and " return " in line:
                is_in_test_case = False
                line = "    return EOK;\n"
                has_insert_here = False

            if not has_insert_here:
                buf.write(line)

        if not has_parse_args:
            print(f"No test$args_parse(...) in main: {test_src}")
            sys.exit(1)
        if not has_exit_code:
            print(f"No return test$exit_code(); in main: {test_src}")
            sys.exit(1)
        if not has_print_footer:
            print(f"No test$print_footer() found: {test_src}")
            sys.exit(1)
        if not has_print_head:
            print(f"No test$print_header() found: {test_src}")
            sys.exit(1)
        if not has_setup:
            print(f"No test$setup() found: {test_src}")
            sys.exit(1)
        fh.close()

        if not self.force_rebuild and not has_c_changes and test_mtime <= build_mtime:
            # No new tests added or changed, prevent touching the source code then
            # print(f"No changes: {all_tests=} {test_calls=} ")
            return False

        if n_tests == 0:
            print(f"No tests found in: {test_src}")
            return False
        else:
            with open(test_src, "w") as fh:
                fh.write(buf.getvalue())
            return True

    def action_build(self):
        test_files_list = []

        if self.src_path == "all":
            for fn in glob.glob(
                os.path.join(self.test_dir, "**", "test_*.c"), recursive=True
            ):
                test_files_list.append(fn)
        else:
            assert os.path.exists(self.src_path), f"test not exist: {self.src_path}"
            assert self.src_path.endswith(".c"), "path must end with .c"
            test_files_list.append(self.src_path)

        compiler_args = [
            "-DCEXTEST",
            "-O0",
            "-g3",
            "-ggdb3",
            "-Wuninitialized",
            # "-pedantic",
            "-Wno-dollar-in-identifier-extension",
            # "-Wno-format-overflow",
            "-Wno-unused-function",
            # "-Wdouble-promotion",
            "-fsanitize-address-use-after-scope",
            "-fsanitize=address",
            "-fsanitize=undefined",
            "-fsanitize=leak",
            "-fstack-protector-strong",
            f"-I{self.test_dir}",
        ]

        if self.ccargs:
            compiler_args += self.ccargs

        for fn in test_files_list:
            if self.action_build_test(fn):
                print(f"Building: {fn}")
                test_exe = self.make_test_exe(fn)
                self.compiler.compile_app(
                    fn, test_exe, compiler_args=compiler_args, linker_args=self.ldargs
                )

    def action_run(self):
        test_exe_list = []

        # Rebuild new before run
        self.action_build()

        if self.src_path == "all":
            for fn in glob.glob(
                os.path.join(self.test_dir, "**", "test_*.c"), recursive=True
            ):
                test_exe_list.append(self.make_test_exe(fn))
        else:
            assert os.path.exists(self.src_path), f"test not exist: {self.src_path}"
            assert self.src_path.endswith(".c"), "path must end with .c"
            test_exe_list.append(self.make_test_exe(self.src_path))

        for fn in test_exe_list:
            args = [
                fn,
            ]

            if self.src_path == "all":
                args.extend(["q"])  # run cex test in quiet mode

            process = subprocess.Popen(
                args,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                # universal_newlines=True,
                # shell=True,
            )
            for line in iter(process.stdout.readline, b""):
                try:
                    print(line.decode().rstrip())
                except UnicodeDecodeError:
                    print(line)

    def action_clean(self):
        build_dir = os.path.join(self.test_dir, "build")
        if self.src_path == "all":
            if os.path.exists(build_dir):
                shutil.rmtree(build_dir)
        else:
            assert os.path.exists(self.src_path), f"test not exist: {self.src_path}"
            assert self.src_path.endswith(".c"), "path must end with .c"
            test_exe = self.make_test_exe(self.src_path)
            if os.path.exists(test_exe):
                os.unlink(test_exe)

    def action_create(self):
        assert self.src_path != "all", "all not supported for `create` action"
        assert not os.path.exists(self.src_path), f"path already exist: {self.src_path}"
        assert self.src_path.endswith(".c"), "path must end with .c"
        assert os.path.basename(self.src_path).startswith(
            "test_"
        ), "test file name must start with test_ prefix"

        test_file = self.src_path

        if not self.src_path.startswith(self.test_dir):
            test_file = os.path.join(self.test_dir, test_file)

        print(f"making: {test_file}")

        os.makedirs(os.path.dirname(test_file), exist_ok=True)

        with open(test_file, "w") as fh:
            fh.write(dedent(CEXTestBuilder.TEMPLATE))

    def build(self):
        if self.action == "create":
            self.action_create()
        elif self.action == "build":
            self.action_build()
        elif self.action == "clean":
            self.action_clean()
        elif self.action == "run":
            self.action_run()
        else:
            raise ValueError(
                f"Incorrect action: {self.action}, expected one of (build, create, run, clean)"  # noqa
            )


class CEXBuilder:
    def __init__(
        self,
        action: str,
        app_name: str,
        target: str,
        ccargs: str,
        ldargs: str,
        out_name: str,
    ):
        self.env = CEXEnv()
        self.app_name = app_name
        self.action = action
        self.target = target
        self.ccargs = ccargs
        self.out_name = out_name
        self.ldargs = ldargs
        self.include_path_cache = {}
        self.compiler = CEXCompiler()
        self.project_root = self.env.get_project_root()

    def make_exe_name(self, app_name: str, out_name: str = None) -> tuple[str, str]:
        os.makedirs(os.path.join(self.project_root, "build"), exist_ok=True)

        if app_name == ".":
            main_path = os.path.join(self.project_root, "src", "main.c")
            if not os.path.exists(main_path):
                raise FileNotFoundError(f"{main_path}")
            if not out_name:
                out_name = os.path.basename(self.project_root)
            return os.path.join(self.project_root, "build", out_name), main_path
        elif app_name == "all":
            raise RuntimeError("all is not supported by this operation")
        else:
            main_path = os.path.join(self.project_root, "src", app_name, "main.c")
            if not os.path.exists(main_path):
                raise FileNotFoundError(f"{main_path}")
            return os.path.join(self.project_root, "build", app_name), main_path

        # return os.path.join(, "build", test_src + ".test")

    def action_build(self, target, app_name, out_name, cc_args, ld_args):

        if target == "debug":
            compiler_args = [
                "-O0",
                "-g3",
                "-ggdb3",
                "-Wuninitialized",
                # "-Wno-format-overflow",
                "-fsanitize-address-use-after-scope",
                "-fsanitize=address",
                "-fsanitize=undefined",
                "-fsanitize=leak",
                "-fstack-protector-strong",
            ]
        elif target == "release-safe":
            compiler_args = [
                "-O3",
                "-fsanitize-address-use-after-scope",
                "-fsanitize=address",
                "-fsanitize=undefined",
                "-fsanitize=leak",
                "-fstack-protector-strong",
            ]
        elif target == "release-fast":
            compiler_args = [
                "-O3",
                "-DNDEBUG",  # disables all asserts
            ]
        elif target == "custom":
            compiler_args = []
        else:
            raise ValueError(
                f"unknown {target=}, supported {{debug,release-safe,release-fast}}"
            )  # noqa

        app_exe, main_path = self.make_exe_name(app_name, out_name)
        self.compiler.compile_app(main_path, app_exe, compiler_args)

    def action_run(self):
        assert False
        test_exe_list = []

        # Rebuild new before run
        self.action_build()

        if self.src_path == "all":
            for fn in glob.glob(
                os.path.join(self.test_dir, "**", "test_*.c"), recursive=True
            ):
                test_exe_list.append(self.make_test_exe(fn))
        else:
            assert os.path.exists(self.src_path), f"test not exist: {self.src_path}"
            assert self.src_path.endswith(".c"), "path must end with .c"
            test_exe_list.append(self.make_test_exe(self.src_path))

        for fn in test_exe_list:
            args = [
                fn,
            ]

            if self.src_path == "all":
                args.extend(["q"])  # run cex test in quiet mode

            process = subprocess.Popen(
                args,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                # universal_newlines=True,
                # shell=True,
            )
            for line in iter(process.stdout.readline, b""):
                print(line.decode().rstrip())

    def action_clean(self):
        assert False
        build_dir = os.path.join(self.test_dir, "build")
        if self.src_path == "all":
            if os.path.exists(build_dir):
                shutil.rmtree(build_dir)
        else:
            assert os.path.exists(self.src_path), f"test not exist: {self.src_path}"
            assert self.src_path.endswith(".c"), "path must end with .c"
            test_exe = self.make_test_exe(self.src_path)
            if os.path.exists(test_exe):
                os.unlink(test_exe)

    def action_create(self):
        assert False
        assert self.src_path != "all", "all not supported for `create` action"
        assert not os.path.exists(self.src_path), f"path already exist: {self.src_path}"
        assert self.src_path.endswith(".c"), "path must end with .c"
        assert os.path.basename(self.src_path).startswith(
            "test_"
        ), "test file name must start with test_ prefix"

        test_file = self.src_path

        if not self.src_path.startswith(self.test_dir):
            test_file = os.path.join(self.test_dir, test_file)

        print(f"making: {test_file}")

        os.makedirs(os.path.dirname(test_file), exist_ok=True)

        with open(test_file, "w") as fh:
            fh.write(dedent(CEXTestBuilder.TEMPLATE))

    def build(self):
        if self.action == "create":
            self.action_create()
        elif self.action == "build":
            self.action_build(
                target=self.target,
                app_name=self.app_name,
                out_name=self.out_name,
                cc_args=self.ccargs,
                ld_args=self.ldargs,
            )
        elif self.action == "clean":
            self.action_clean()
        elif self.action == "run":
            self.action_run()
        else:
            raise ValueError(
                f"Incorrect action: {self.action}, expected one of (build, create, run, clean)"  # noqa
            )


class CEXProcessor:
    RE_COMMENT_LINE = re.compile(r"^\s*//", re.MULTILINE)
    RE_COMMENT_ML_START = re.compile(r"^\s*\/\*", re.MULTILINE)
    RE_COMMENT_ML_END = re.compile(r".*\*\/", re.MULTILINE)
    RE_CODE_START_LINE = re.compile(r"^[a-zA-Z_0-9\*]+\s+", re.MULTILINE)
    RE_FUNC = re.compile(r"(.*)\s+(\w+)\({1}([\w,\[\]\(\)\s\*\.]+)\)", re.MULTILINE)
    RE_STATIC = re.compile(r"(^static\s|\sstatic\s|\sstatic$)", re.MULTILINE)
    RE_INLINE = re.compile(r"(^inline\s|\sinline\s|\sinline$)", re.MULTILINE)

    class Block:
        """Generic code block

        Attributes:
            buf: code buffer
            line_start: start line of block
            line_end: end line of block
        """

        def __init__(self, line_start: int):
            self.buf = io.StringIO()
            self.line_start = line_start
            self.line_end = None

        def __str__(self):
            return self.__class__.__qualname__

        def __repr__(self):
            return f"Block: {str(self)} [{self.line_start}:{self.line_end}]\n{self.buf.getvalue()}"  # noqa

        @staticmethod
        def probe(line: str) -> bool:
            """Probes new block type based on line of code"""
            return False

        def process_line(self, line: str) -> bool:
            """Process line of code in initialized block"""
            raise NotImplementedError()

    class Comment(Block):
        """Commentary block

        Attributes:
            comment_type: 'm' - multi line, 's' - single line
        """

        def __init__(self, line_start):
            self.comment_type = None
            super().__init__(line_start)

        def __str__(self):
            return f"Comment({self.comment_type}) [{self.line_start}:{self.line_end}]"

        @staticmethod
        def probe(line: str) -> bool:
            return CEXProcessor.RE_COMMENT_LINE.search(
                line
            ) or CEXProcessor.RE_COMMENT_ML_START.search(line)

        def process_line(self, line: str) -> bool | None:
            if self.comment_type is None:
                if CEXProcessor.RE_COMMENT_ML_START.search(line):
                    self.comment_type = "m"
                elif CEXProcessor.RE_COMMENT_LINE.search(line):
                    self.comment_type = "s"
                else:
                    raise ValueError("Unsupproted commet")

                self.buf.write(line)

                # Single line contains comment end mark
                if CEXProcessor.RE_COMMENT_ML_END.search(line):
                    return False

                return True
            else:
                if self.comment_type == "s":
                    if CEXProcessor.RE_COMMENT_LINE.search(line):
                        self.buf.write(line)
                        return True
                    else:
                        return None  # Unknown line, probe next block
                else:
                    # In multiline comment, write all until end

                    if CEXProcessor.RE_COMMENT_ML_END.search(line):
                        self.buf.write(line.replace("\n", ""))
                        return False  # Block ended
                    else:
                        self.buf.write(line)
                        return True  # Block continues

    class Code(Block):
        """Code block

        Attributes:
            code_type: "func", "var", "struct"
        """

        def __init__(self, line_start):
            self.code_type = None
            self._is_signature = True
            self._in_string_quotes = []
            self._brstack = []
            self._brackets: dict = {
                "[": "]",
                "]": None,
                "(": ")",
                ")": None,
                "{": "}",
                "}": None,
            }
            self._comment = None
            super().__init__(line_start)

        def __str__(self):
            return f"Code({self.code_type})[{self.line_start}:{self.line_end}]"

        @staticmethod
        def probe(line: str) -> bool:
            assert not CEXProcessor.RE_COMMENT_LINE.search(line)
            assert not CEXProcessor.RE_COMMENT_ML_START.search(line)
            return CEXProcessor.RE_CODE_START_LINE.search(line)

        def process_brackets(self, c: str):
            assert len(c) == 1
            assert c in self._brackets
            if not self._brstack:
                assert (
                    self._brackets[c] is not None
                ), f"Must be opening bracket: c={c}\n{self.buf.getvalue()}"
                self._brstack.append(c)
            else:
                if self._brackets[self._brstack[-1]] == c:
                    # c is closing bracket
                    self._brstack.pop(-1)
                else:
                    # new bracket level
                    assert (
                        self._brackets[c] is not None
                    ), f"Must be opening bracket: c={c}\n{self.buf.getvalue()}"
                    self._brstack.append(c)
            pass

        def process_line(self, line: str) -> bool | None:
            if not self._comment:
                if CEXProcessor.Comment.probe(line):
                    self._comment = CEXProcessor.Comment(-1)
                    if not self._comment.process_line(line):
                        self._comment = None
                    return True
            else:
                cmt = self._comment.process_line(line)
                if cmt:
                    return True
                else:
                    self._comment = None
                    if cmt is not None:
                        return True

            line = line.strip()
            for i, c in enumerate(line):
                # We are in signature
                if self._is_signature:
                    # Decide definition type based on signature
                    if c in self._brackets:

                        if c == "(":
                            self.code_type = "func"
                        elif c == "{":
                            assert (
                                not self._brstack
                            ), f"No all brackets closed: {self._brstack}"
                            # Function signature is completed, started implementation
                            self._is_signature = False
                            if self.code_type is None:
                                if "struct " in self.buf.getvalue():
                                    self.code_type = "struct"

                        self.process_brackets(c)
                    elif c == "=":
                        self.code_type = "var"
                    elif c == ";":
                        # Reached the end while in signature
                        # assert self.code_type == "func", f"{self.code_type}"
                        if self.code_type is None:
                            if "extern " in self.buf.getvalue():
                                self.code_type = "var"
                        if self.code_type == "func":
                            if "typedef " in self.buf.getvalue():
                                self.code_type = "type"
                            else:
                                self.code_type = "decl"
                        # Return block end
                        return False

                    if self._is_signature:
                        self.buf.write(c)
                else:
                    if not self._in_string_quotes and c != '"' and c != "'":
                        if c in self._brackets:
                            self.process_brackets(c)

                        if len(self._brstack) == 0:

                            # Handle last closing bracket of a function
                            if self.code_type == "func":
                                if c == "}":
                                    return False
                            elif self.code_type == "var":
                                if c == ";":
                                    return False
                            else:
                                if c == ";":
                                    return False
                    else:
                        if not self._in_string_quotes:
                            self._in_string_quotes.append(c)
                        else:
                            if c == '"' or c == "'":
                                # NOTE: special case for backslash '\\', "\\"
                                if i >= 2 and (
                                    line[i - 1] != "\\"
                                    or (line[i - 1] == "\\" and line[i - 2] == "\\")
                                ):
                                    # escaped quote, skipping \"
                                    if c == self._in_string_quotes[-1]:
                                        self._in_string_quotes.pop()
                                    else:
                                        self._in_string_quotes.append(c)

                    pass

            if self._is_signature:
                self.buf.write(" ")
            return True

    class Func:
        """Function metadata

        Attributes:
            is_static: function defined as static
            is_inline: function defined as inline
            typedef: function type definition part
            name: function full name
            args: function full arguments
            docstr: comment block prior function
            sub_module: function sub module, e.g _<namespace>__<sub_module>__<name>
            ifc_name: function interface short name
        """

        def __init__(self, decl: str, ifc_prefix: str):
            g = CEXProcessor.RE_FUNC.match(decl)
            assert g, f"Function regex not matched: {decl}"
            self.is_static = False
            self.is_inline = False
            typedef = g.group(1)

            if CEXProcessor.RE_STATIC.search(typedef):
                self.is_static = True
                typedef = CEXProcessor.RE_STATIC.sub(" ", typedef)
            if CEXProcessor.RE_INLINE.search(typedef):
                self.is_inline = True
                typedef = CEXProcessor.RE_INLINE.sub(" ", typedef)

            self.ifc_prefix = ifc_prefix
            self.typedef = typedef.strip()
            self.name = g.group(2).strip()
            self.args = g.group(3).strip()

            self.args = self.args.replace(" restrict ", " ")
            self.docstr = ""

            g = re.match(rf"^{ifc_prefix}__([\w]+)__(\w+)", self.name, re.MULTILINE)
            if g:
                self.sub_module = g.group(1)
                self.ifc_name = g.group(2)
                assert self.ifc_name
            elif g := re.match(rf"^{ifc_prefix}_(\w+)", self.name, re.MULTILINE):
                self.sub_module = None
                self.ifc_name = g.group(1)
                assert self.ifc_name
            else:
                # Not in namespace
                self.ifc_name = None
                self.sub_module = None

            assert (
                "(" not in self.typedef and ")" not in self.typedef
            ), f"function pointers?? {self}"

        @property
        def is_public_cex(self) -> bool:
            if self.is_inline and self.is_static:
                return False

            g = re.match(
                rf"^{self.ifc_prefix}__([\w]+)__(\w+)", self.name, re.MULTILINE
            )
            if not g and f"{self.ifc_prefix}__" in self.name:
                # private function, and not second level namespace
                return False

            return True

        def to_pointer_decl(self, indent: bool) -> str:
            """Function declaration for .h struct

            Args:
                indent: indent type def and name

            Returns:

            """
            assert self.ifc_name, "not in namespace"

            if indent:
                return f"{self.typedef}\n(*{self.ifc_name})({self.args});\n"
            else:
                return f"{self.typedef} (*{self.ifc_name})({self.args});\n"

        def to_pointer_def(self) -> str:
            """Function .c struct field definition"""
            assert self.ifc_name, "not in namespace"

            return f"    .{self.ifc_name} = {self.name},"

        def __repr__(self):
            return f"""
    Function:
        typedef: {self.typedef}
        is_static: {self.is_static}
        is_inline: {self.is_inline}
        name: {self.name}
        args: {self.args}
        """

    def __init__(self, src_file: str, namespace: str = None):
        """CEX Module generator initializer

        Args:
            c_file: path to .c file
            h_file: path to .h file
            namespace:
        """

        if src_file.endswith(".c"):
            self.c_file = src_file
            assert os.path.exists(self.c_file), f"{self.c_file=} not exists"

            self.h_file = src_file[:-2] + ".h"
            assert os.path.exists(self.h_file), f"{self.h_file=} not exists"

            self.is_public_header = False
        elif src_file.endswith(".h"):
            self.h_file = src_file
            assert os.path.exists(self.h_file), f"{self.h_file=} not exists"

            self.c_file = src_file[:-2] + ".c"
            assert os.path.exists(self.c_file), f"{self.c_file=} not exists"

            self.is_public_header = True
        else:
            raise ValueError(f"bad {src_file}")

        if namespace:
            self.namespace = namespace
        else:
            self.namespace = os.path.basename(self.h_file).replace(".h", "")

        ns = self.namespace
        if self.is_public_header:
            self.ns_struct_name = f"__header__{ns}"
        else:
            if ns == ns.lower():
                self.ns_struct_name = f"__module__{ns}"
            else:
                self.ns_struct_name = f"__class__{ns}"

    @staticmethod
    def block_probe(line: str, lineno: int) -> Block | None:
        """Probed block type"""
        if CEXProcessor.Comment.probe(line):
            return CEXProcessor.Comment(lineno)
        if CEXProcessor.Code.probe(line):
            return CEXProcessor.Code(lineno)
        return None

    def parse_source(self, c_file) -> tuple[list[str], list[Block]]:
        """Parses source for lines and list of Blocks"""
        assert os.path.exists(c_file), f"File not exists: {c_file}"

        with open(c_file, "r") as fh:
            lines = fh.readlines()

        blocks = []
        current_block: CEXProcessor.Block | None = None
        for i, line in enumerate(lines):
            while True:
                if current_block is None:
                    current_block = self.block_probe(line, i)

                if current_block:
                    lres = current_block.process_line(line)
                    if not lres:
                        # block ended at this line
                        blocks.append(current_block)
                        # print(repr(current_block))

                        if lres is None:
                            # previous block demanded next probe, at current line!
                            current_block.line_end = i - 1
                            current_block = None
                            continue
                        else:
                            current_block.line_end = i
                            current_block = None
                # process next source line
                break

        return lines, blocks

    def is_func_code(self, block: Code):
        isinstance(block, CEXProcessor.Code)

        if self.is_public_header:
            if block.code_type == "decl":
                return True
        else:
            if block.code_type == "func":
                return True
        return False

    def make_interface_declaration(self, blocks: list[Block]):
        """Generates CEX interface declaration in .h file"""
        ns = self.namespace
        ns_struct_name = self.ns_struct_name
        ifc_contents = []
        ifc_contents.append(f"struct {ns_struct_name}")
        ifc_contents.append("{")
        ifc_contents.append("    // Autogenerated by CEX")
        ifc_contents.append("    // clang-format off\n")
        functions: dict[str | None, list[CEXProcessor.Func]] = {}
        for i, b in enumerate(blocks):

            # print(repr(b))
            if isinstance(b, CEXProcessor.Code):
                if self.is_func_code(b):
                    f = CEXProcessor.Func(b.buf.getvalue(), ns)
                    if f.ifc_name and f.is_public_cex:
                        if i > 0 and isinstance(blocks[i - 1], CEXProcessor.Comment):
                            f.docstr = blocks[i - 1].buf.getvalue()
                        flist = functions.setdefault(f.sub_module, [])
                        flist.append(f)

        assert (
            functions
        ), f"No functions passed module filter, expected prefix: {self.namespace}_"

        for sub_module, flist in functions.items():
            if sub_module:
                ifc_contents.append(f"\nstruct {{  // sub-module .{sub_module} >>>")

            def dd(txt):
                return indent(txt, "    ") if sub_module else txt

            for func in flist:
                if func.docstr:
                    ifc_contents.append(dd(func.docstr))
                ifc_contents.append(dd(func.to_pointer_decl(indent=True)))

            if sub_module:
                ifc_contents.append(
                    f"}} {sub_module};  // sub-module .{sub_module} <<<"
                )
            pass

        ifc_contents.append("    // clang-format on")
        if not self.is_public_header:
            ifc_contents.append("};")
            # NOTE: need extra line for endif handling
            # Algo, no empty lines should be between declaration and extern,
            #  because empty line remains and stacking at consequent calls
            ifc_contents.append(
                f"extern const struct {ns_struct_name} {ns}; // CEX Autogen\n"
            )
        else:
            # NOTE: need extra line for endif handling
            ifc_contents.append("};\n")

        return ifc_contents

    def make_interface_definition(self, blocks: list[Block]):
        """Generates CEX interface definition (in .c file)"""
        ns = self.namespace
        ns_struct_name = self.ns_struct_name

        ifc_contents = []
        ifc_contents.append(f"const struct {ns_struct_name} {ns} = {{")
        ifc_contents.append("    // Autogenerated by CEX")
        ifc_contents.append("    // clang-format off")
        functions: dict[str | None, list[CEXProcessor.Func]] = {}
        for i, b in enumerate(blocks):
            if isinstance(b, CEXProcessor.Code):
                if self.is_func_code(b):
                    f = CEXProcessor.Func(b.buf.getvalue(), ns)
                    if f.ifc_name and f.is_public_cex:
                        if f.is_inline and not f.is_static:
                            raise ValueError(
                                f"Function: {f.name} must be have static with inline"
                            )
                        if i > 0 and isinstance(blocks[i - 1], CEXProcessor.Comment):
                            f.docstr = blocks[i - 1].buf.getvalue()
                        flist = functions.setdefault(f.sub_module, [])
                        flist.append(f)

        assert functions, "No functions passed module filter"

        for sub_module, flist in functions.items():
            if sub_module:
                ifc_contents.append(
                    f"\n    .{sub_module} = {{  // sub-module .{sub_module} >>>"
                )

            def dd(txt):
                return indent(txt, "    ") if sub_module else txt

            for func in flist:
                ifc_contents.append(dd(func.to_pointer_def()))

            if sub_module:
                ifc_contents.append(f"    }},  // sub-module .{sub_module} <<<")
            pass

        ifc_contents.append("    // clang-format on")
        ifc_contents.append("};")

        return ifc_contents

    def clean_old_struct_code(
        self, src_lines: list[str], src_blocks: list[Block]
    ) -> int:
        """Cleans old source from previews CEX declarations/definitions"""
        existing = []
        last_ifndef = None
        for b in src_blocks:
            if isinstance(b, CEXProcessor.Code) and b.code_type in ["var", "struct"]:
                code_line = b.buf.getvalue()
                if self.ns_struct_name in code_line:
                    existing.append(b)

        for b in reversed(existing):
            # print(f"exists at: {b}")
            del src_lines[int(b.line_start) : int(b.line_end) + 1]  # noqa

        for i, line in enumerate(reversed(src_lines)):
            if line.strip() == "":
                continue
            # Check #endif guard
            if line.strip().startswith("#endif"):
                last_ifndef = len(src_lines) - i - 1
            break
        return last_ifndef

    def make_fff_fake(
        self, fake_dir: str, h_file: str, blocks: list[Block], sub_module: str = ""
    ):
        assert os.path.exists(fake_dir), f"{fake_dir} not exists"

        if h_file.startswith("./"):
            h_file = h_file[2:]

        src = io.StringIO()
        src_reset = io.StringIO()
        src_wrap = io.StringIO()
        src_wrap_reset = io.StringIO()
        src.write("// Autogenerated <fff.h> mocks\n")
        src.write("// NOTE: Do not edit, all changes can be lost\n")
        src.write("\n// clang-format off\n")
        src.write("#include <fff.h>\n")
        src.write(f"#include <{h_file}>\n\n")
        src_wrap.write(src.getvalue())
        src_wrap.write(
            "// IMPORTANT: wrapping works only with gcc  `-Wl,--wrap=Shmem_new,--wrap=Protocol_event_emitter_new`  flag"  # noqa
        )
        fake_count = 0

        _RE_COMBINE_WHITESPACE = re.compile(r"\s+")

        file = h_file
        base_file = "fake__" + file.replace("../", "").replace("include/", "").replace(
            "src/", ""
        ).replace("/", "__")

        if sub_module:
            base_file = base_file.replace(".h", f"__{sub_module}.h")

        wrap_fake = base_file.replace(".h", "__wrap.h")

        src_reset.write("\n// clang-format off\n")
        src_wrap_reset.write("\n// clang-format off\n")
        src_reset.write(
            f"\n\nstatic void {base_file.replace('.h', '__resetall(void) {')}\n"
        )
        src_wrap_reset.write(
            f"\n\nstatic void {wrap_fake.replace('.h', '__resetall(void) {')}\n"
        )

        for block in blocks:
            if not isinstance(block, CEXProcessor.Code) or not self.is_func_code(block):
                continue

            f = CEXProcessor.Func(block.buf.getvalue(), "")
            if not f.is_public_cex:
                continue

            is_var_args = False

            sig_args = []
            fargs = f.args.split(",")
            for a in fargs:
                # make argument string exactly 1 space separated
                a = _RE_COMBINE_WHITESPACE.sub(" ", a).strip()

                subargs = a.split(" ")
                if "[" in subargs[-1]:
                    subargs[-1] = "*"
                elif "..." == subargs[-1]:
                    is_var_args = True
                else:
                    del subargs[-1]

                a = " ".join(subargs)
                if a:
                    sig_args.append(a)
            fake_count += 1

            # print(sig_args)
            sig_args_prefix = ", " if sig_args else ""
            src.write("\n")
            src_wrap.write("\n")
            var_arg_prefix = "_VARARG" if is_var_args else ""

            if f.typedef.strip() == "void":
                src.write(
                    f"FAKE_VOID_FUNC{var_arg_prefix}({f.name}{sig_args_prefix}{', '.join(sig_args)})"  # noqa
                )
                src_wrap.write(
                    f"FAKE_VOID_FUNC{var_arg_prefix}(__wrap_{f.name}{sig_args_prefix}{', '.join(sig_args)})"  # noqa
                )
                src_wrap.write(f"void __real_{f.name}({', '.join(sig_args)});\n")
            else:
                ret_val = f.typedef
                ret_val = ret_val.replace("UErr_exc", "UErr_e")
                ret_val = ret_val.replace("Exception", "Exc")
                ret_val = ret_val.replace("ExcSkip", "Exc")
                src.write(
                    f"FAKE_VALUE_FUNC{var_arg_prefix}({ret_val}, {f.name}{sig_args_prefix}{', '.join(sig_args)})"  # noqa
                )
                src_wrap.write(
                    f"FAKE_VALUE_FUNC{var_arg_prefix}({ret_val}, __wrap_{f.name}{sig_args_prefix}{', '.join(sig_args)})"  # noqa
                )
                src_wrap.write(f"{f.typedef} __real_{f.name}({', '.join(sig_args)});\n")

            src_reset.write(f"    RESET_FAKE({f.name})\n")
            src_wrap_reset.write(f"    RESET_FAKE(__wrap_{f.name})\n")

        src.write("\n\n")
        src_wrap.write("\n\n")

        src_reset.write("}\n\n")
        src_wrap_reset.write("}\n\n")

        if not self.is_public_header:
            c_ifc_impl = self.make_interface_definition(blocks)
            src.write("\n".join(c_ifc_impl))
            src_wrap.write("\n".join(c_ifc_impl))

        with open(os.path.join(fake_dir, base_file), "w") as fh:
            fh.write(src.getvalue())
            fh.write(src_reset.getvalue())

        if not sub_module:
            with open(os.path.join(fake_dir, wrap_fake), "w") as fh:
                fh.write(src_wrap.getvalue())
                fh.write(src_wrap_reset.getvalue())

    def build(self, fake_dir):
        """Build CEX module"""
        c_lines, c_blocks = self.parse_source(self.c_file)
        h_lines, h_blocks = self.parse_source(self.h_file)

        ifc_decl = self.make_interface_declaration(c_blocks)
        ifc_def = self.make_interface_definition(c_blocks)

        self.clean_old_struct_code(c_lines, c_blocks)
        endif_guard = self.clean_old_struct_code(h_lines, h_blocks)

        if endif_guard:
            # ifc_decl.append('\n')
            h_lines.insert(endif_guard, "\n".join(ifc_decl))
        else:
            h_lines.append("\n".join(ifc_decl))
        c_lines.append("\n".join(ifc_def))

        with open(self.c_file, "w") as fh:
            fh.writelines(c_lines)
        with open(self.h_file, "w") as fh:
            fh.writelines(h_lines)

        if fake_dir:
            self.make_fff_fake(fake_dir, self.h_file, c_blocks)

    def build_header(self, fake_dir):
        """Build CEX module"""
        h_lines, h_blocks = self.parse_source(self.h_file)

        ifc_decl = self.make_interface_declaration(h_blocks)
        ifc_def = self.make_interface_definition(h_blocks)

        self.clean_old_struct_code(h_lines, h_blocks)
        endif_guard = self.clean_old_struct_code(h_lines, h_blocks)

        if endif_guard:
            h_lines.insert(endif_guard, "\n".join(ifc_decl))
        else:
            h_lines.append("\n".join(ifc_decl))
        h_lines.append("\n".join(ifc_def))

        # print("\n".join(h_lines))
        with open(self.h_file, "w") as fh:
            fh.writelines(h_lines)

        if fake_dir:

            # Make fake for whole app
            self.make_fff_fake(fake_dir, self.h_file, h_blocks, "")

            sub_module_blocks = {}

            for block in h_blocks:
                if not isinstance(block, CEXProcessor.Code) or not self.is_func_code(
                    block
                ):
                    continue

                f = CEXProcessor.Func(block.buf.getvalue(), self.namespace)
                if not f.is_public_cex:
                    continue
                sub_mod = f.sub_module if f.sub_module else ""
                flist = sub_module_blocks.setdefault(sub_mod, [])
                flist.append(block)

            # Make fake for individual sub modules
            for sub_mod, funcs_blocks in sub_module_blocks.items():
                if not sub_mod.strip():
                    sub_mod = "unknown"
                self.make_fff_fake(fake_dir, self.h_file, funcs_blocks, sub_mod)


def action_test(args):
    builder = CEXTestBuilder(
        args.action,
        src_path=args.test_file,
        test_dir=args.testdir,
        force_rebuild=args.force,
        ccargs=args.ccargs,
        ldargs=args.ldargs,
    )
    builder.build()


def action_env(args):
    env = CEXEnv()
    print(repr(env))


def action_build(args):
    builder = CEXBuilder(
        args.action,
        app_name=args.app_name,
        target=args.target,
        ccargs=args.ccargs,
        ldargs=args.ldargs,
        out_name=args.outname,
    )
    builder.build()


def action_process(args):
    src_path = args.source_path

    sources = {}
    headers = {}

    if os.path.isdir(src_path):
        print("CEX Updating exising modules\n")
        re_cex_module = re.compile(r"const struct __(class|module)__")
        re_cex_header = re.compile(r"const struct __header__")

        for fn in glob.glob("**/*.c", recursive=True):
            if os.path.basename(fn).startswith("test_") or os.path.basename(
                fn
            ).startswith("fake_"):
                continue
            if fn.endswith("include/cex.c"):
                # ignore bundles
                continue
            sources[fn] = None
        for fn in glob.glob("**/*.h", recursive=True):
            if os.path.basename(fn).startswith("test_") or os.path.basename(
                fn
            ).startswith("fake_"):
                continue
            if fn.endswith("include/cex.h"):
                # ignore bundles
                continue
            if os.path.basename(fn) == "fff.h":
                # ignore bundles
                continue
            headers[fn] = None

        for fn in sources:
            with open(fn, "r") as fh:
                content = fh.read()
                if re_cex_module.search(content):
                    print(f"CEX bulding: {fn}")
                    h_file = fn[:-2] + ".h"
                    if h_file in headers:
                        # remove .h file mapped to the current source, no double read
                        del headers[h_file]
                    builder = CEXProcessor(fn, namespace=args.namespace)
                    builder.build(args.fakedir)

        for fn in headers:
            with open(fn, "r") as fh:
                content = fh.read()
                if re_cex_header.search(content):
                    print(f"CEX bulding: {fn}")
                    builder = CEXProcessor(fn, namespace=args.namespace)
                    builder.build_header(args.fakedir)

    else:
        print(f"CEX building: {src_path}")
        builder = CEXProcessor(src_path, namespace=args.namespace)
        if builder.is_public_header:
            builder.build_header(args.fakedir)
        else:
            builder.build(args.fakedir)


if __name__ == "__main__":
    global_parser = argparse.ArgumentParser()
    subparsers = global_parser.add_subparsers(
        required=True, title="subcommands", help="CEX operations"
    )

    process_parser = subparsers.add_parser(
        "process", help="tranforms or updates source code into CEX namespace"
    )
    process_parser.add_argument(
        "source_path",
        help="Directory (batch update mode), or file path .c (code mode) or .h (lib mode)",  # noqa
    )
    process_parser.add_argument("--fakedir", help="fff.h fake directory", default="")
    process_parser.add_argument(
        "--namespace",
        help="module/class namespace, inferred from file name",
        default=None,
    )
    process_parser.set_defaults(func=action_process)

    test_parser = subparsers.add_parser("test", help="CEX test manager runner")
    test_parser.add_argument(
        "action", help="test action {create, run, build, debug, clean}"
    )
    test_parser.add_argument(
        "-d", "--testdir", help="Root directory of tests", default="tests"
    )
    test_parser.add_argument(
        "-f",
        "--force",
        help="Force test rebuild before command",
        default=False,
        action="store_true",
    )
    test_parser.add_argument("test_file", help="File path to cex test .c file")
    test_parser.add_argument("--ccargs", help="compiler arguments", default="")
    test_parser.add_argument("--ldargs", help="linker arguments", default="")
    test_parser.set_defaults(func=action_test)

    env_parser = subparsers.add_parser(
        "env", help="CEX environment variables / diagnostics"
    )
    env_parser.set_defaults(func=action_env)

    build_parser = subparsers.add_parser("app", help="CEX app management")
    build_parser.add_argument(
        "action",
        help="app action {create, run, build, debug, clean}",
    )
    build_parser.add_argument(
        "app_name",
        help=". for src/main.c, or `my_app_name` for src/<my_app_name>/main.c, or `all`",  # noqa
    )
    build_parser.add_argument(
        "-o",
        "--outname",
        help="Application output name, in build/<outname>",
        default="",
    )
    build_parser.add_argument(
        "--target",
        help="compiler args preset: {debug, release-safe, release-fast, custom}, default: debug",  # noqa
        default="debug",
    )
    build_parser.add_argument("--ccargs", help="compiler arguments", default="")
    build_parser.add_argument("--ldargs", help="linker arguments", default="")
    build_parser.set_defaults(func=action_build)

    cli_arguments = global_parser.parse_args()
    cli_arguments.func(cli_arguments)
