#include "io.h"
#include "cex/cex.h"


Exception
io_fopen(io_c* self, const char* filename, const char* mode, const Allocator_c* allocator)
{
    if (self == NULL) {
        uassert(self != NULL);
        return Error.argument;
    }
    if (filename == NULL) {
        uassert(filename != NULL);
        return Error.argument;
    }
    if (mode == NULL) {
        uassert(mode != NULL);
        return Error.argument;
    }
    if (allocator == NULL) {
        uassert(allocator != NULL);
        return Error.argument;
    }


    *self = (io_c){
        ._fh = allocator->fopen(filename, mode),
        ._allocator = allocator,
    };

    if (self->_fh == NULL) {
        memset(self, 0, sizeof(*self));
        return raise_exc(Error.io, "%s, file: %s\n", strerror(errno), filename);
    }

    return Error.ok;
}

Exception
io_fattach(io_c* self, FILE* fh, const Allocator_c* allocator)
{
    if (self == NULL) {
        uassert(self != NULL);
        return Error.argument;
    }
    if (allocator == NULL) {
        uassert(allocator != NULL);
        return Error.argument;
    }
    if (fh == NULL) {
        uassert(fh != NULL);
        return Error.argument;
    }

    *self = (io_c){
        ._fh = fh,
        ._allocator = allocator,
        ._flags = {
            .is_attached = true,
        }
    };

    return Error.ok;
}

size_t
io_size(io_c* self)
{
    uassert(self != NULL);
    uassert(self->_fh != NULL);

    if (self->_fsize == 0) {
        // Do some caching
        i64 old_pos = ftell(self->_fh);
        if (fseek(self->_fh, 0, SEEK_END) == -1) {
            return 0;
        }
        self->_fsize = ftell(self->_fh);
        // restore old position if any
        fseek(self->_fh, old_pos, SEEK_SET);
    }

    return self->_fsize;
}

Exception
io_readall(io_c* self, sview_c* s)
{
    uassert(self != NULL);
    uassert(self->_fh != NULL);
    uassert(s != NULL);

    // invalidate result if early exit
    *s = (sview_c){
        .buf = NULL,
        .len = 0,
    };

    // Check if it's possible to seek file, it should fail if pipe/socket/stdin
    if (unlikely(fseek(self->_fh, 0, SEEK_END) == -1)) {
        return raise_exc(Error.io, "fseek error, maybe pipe/socket/std[in/out/err]: %s\n", strerror(errno));
    }
    self->_fsize = ftell(self->_fh);
    fseek(self->_fh, 0, SEEK_SET);

    if (unlikely(self->_fsize == 0)) {
        return Error.empty;
    }

    uassert(self->_fbuf == NULL && "TODO: handle already allocated");
    self->_fbuf = self->_allocator->alloc(self->_fsize + 1 + 16);
    if (unlikely(self->_fbuf == NULL)) {
        return Error.memory;
    }
    // allocate extra 16 bytes, to catch condition when file size grows
    // this may be indication we are trying to read stream
    self->_fbuf_size = self->_fsize + 1 + 16;

    size_t bytes_read = fread(self->_fbuf, sizeof(char), self->_fbuf_size, self->_fh);

    if (bytes_read != self->_fsize) {
        utracef("%ld != %ld: %s\n", bytes_read, self->_fsize, strerror(errno));
        if (!feof(self->_fh) && ferror(self->_fh)) {
            return Error.io;
        } else {
            return "File size changed";
        }
    }

    *s = (sview_c){
        .buf = self->_fbuf,
        .len = bytes_read,
    };

    // Always null terminate
    self->_fbuf[bytes_read] = '\0';

    return Error.ok;
}

void
io_close(io_c* self)
{
    if (self != NULL) {
        uassert(self->_allocator != NULL && "allocator not set");

        if (self->_fh != NULL && !self->_flags.is_attached) {
            // prevent closing attached FILE* (i.e. stdin/out or other)
            self->_allocator->fclose(self->_fh);
        }

        if (self->_fbuf != NULL) {
            self->_allocator->free(self->_fbuf);
        }

        memset(self, 0, sizeof(*self));
    }
}


const struct __module__io io = {
    // Autogenerated by CEX
    // clang-format off
    .fopen = io_fopen,
    .fattach = io_fattach,
    .size = io_size,
    .readall = io_readall,
    .close = io_close,
    // clang-format on
};
