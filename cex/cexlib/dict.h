#pragma once
#include "cex.h"
#include "str.h"
#include <string.h>

typedef struct dict_c
{
    void* hashmap; // any generic hashmap implementation
} dict_c;

typedef u64 (*dict_hash_func_f)(const void* item, u64 seed0, u64 seed1);
typedef i32 (*dict_compare_func_f)(const void* a, const void* b, void* udata);
typedef void (*dict_elfree_func_f)(void* item);


// Hack for getting hash/cmp functions by a type of key field
// https://gustedt.wordpress.com/2015/05/11/the-controlling-expression-of-_generic/
// FIX: this is not compatible with MSVC
#define _dict$hashfunc_field(strucfield)                                                           \
    _Generic(&(strucfield), u64 *: hm_int_hash, char(*)[]: hm_str_static_hash)

#define _dict$cmpfunc_field(strucfield)                                                            \
    _Generic(&(strucfield), u64 *: hm_int_compare, char(*)[]: hm_str_static_compare)

#define _dict$hashfunc(struct, field) _dict$hashfunc_field(((struct){ 0 }.field))

#define _dict$cmpfunc(struct, field) _dict$cmpfunc_field(((struct){ 0 }.field))



#define dict$new(self, struct_type, key_field_name, allocator)                                     \
    dict.create(                                                                                   \
        self,                                                                                      \
        sizeof(struct_type),                                                                       \
        _Alignof(struct_type),                                                                     \
        offsetof(struct_type, key_field_name),                                                     \
        0, /* capacity = 0, default is 16 */                                                       \
        _dict$hashfunc(struct_type, key_field_name),                                               \
        _dict$cmpfunc(struct_type, key_field_name),                                                \
        allocator,                                                                                 \
        NULL, /* elfree - function for clearing elements */                                        \
        NULL  /* udata - passed as a context for cmp funcs */                                      \
    )


struct __module__dict
{
    // Autogenerated by CEX
    // clang-format off

Exception
(*create)(dict_c* self, size_t item_size, size_t item_align, size_t item_key_offsetof, size_t capacity, dict_hash_func_f hash_func, dict_compare_func_f compare_func, const Allocator_i* allocator, dict_elfree_func_f elfree, void* udata);

/**
 * @brief Set or replace dict item
 *
 * @param self dict() instance
 * @param item  item key/value struct
 * @return error code, EOK (0!) on success, positive on failure
 */
Exception
(*set)(dict_c* self, const void* item);

/**
 * @brief Get item by integer key
 *
 * @param self dict() instance
 * @param key u64 key
 */
void*
(*geti)(dict_c* self, u64 key);

/**
 * @brief Get item by generic key pointer (including strings)
 *
 * @param self dict() instance
 * @param key generic pointer key
 */
void*
(*get)(dict_c* self, const void* key);

/**
 * @brief Number elements in dict()
 *
 * @param self  dict() instance
 * @return number
 */
size_t
(*len)(dict_c* self);

/**
 * @brief Free dict() instance
 *
 * @param self  dict() instance
 * @return always NULL
 */
void
(*destroy)(dict_c* self);

/**
 * @brief Clear all elements in dict (but allocated capacity unchanged)
 *
 * @param self dict() instane
 */
void
(*clear)(dict_c* self);

/**
 * @brief Delete item by integer key
 *
 * @param self dict() instance
 * @param key u64 key
 */
void*
(*deli)(dict_c* self, u64 key);

/**
 * @brief Delete item by generic key pointer (including strings)
 *
 * @param self dict() instance
 * @param key generic pointer key
 */
void*
(*del)(dict_c* self, const void* key);

void*
(*iter)(dict_c* self, cex_iterator_s* iterator);

Exception
(*tolist)(dict_c* self, void* listptr, const Allocator_i* allocator);

    // clang-format on
};
extern const struct __module__dict dict; // CEX Autogen
